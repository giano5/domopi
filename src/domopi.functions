#!/bin/false
#	La prima riga impedisce di essere utilizzato come programma.
#	E' solo una libreria.
#
# DomoPI API
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation, either version 3 of the License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
#    Copyrights (C) 2016 
#
#	 @date:
#	 @version:
#

# Global variables
DOMOPI_CONF_PATH=.
DOMOPI_BIN_PATH=.
# Percorso istallazione di questo file (ad uso interno)
DOMOPI_API_PATH=domopi.functions

# Requisiti
DOMOPI_REQUIRES="awk bc cut egrep grep sed tr"

declare -A DOMOPI_FILE_SCHEMA

# Configuration files
DOMOPI_IDENT_FILE=$DOMOPI_CONF_PATH/ident.cfg
DOMOPI_GLOBAL_CONF=$DOMOPI_CONF_PATH/global.cfg
DOMOPI_FILE_FINGERPRINT='# Automatically generatedfile: do not modify!'

# Schema is for generate initial configuration
DOMOPI_FILE_SCHEMA['global']='# groupID:moduleID:sensorID:patchin:patchout:wiredpi:type:mode:maxexecutiontime:order:defaultstate:currentstate:descriptionU:alias:groups'
# NOTA: In caso di bash < 4.2 dichiarare a questo livello
#declare -A DOMOPI_SCHEMA_COL_global

unset DOMOPI_FILE_DESCRIPTORS
declare -a DOMOPI_FILE_DESCRIPTORS
# Declare standard opened
DOMOPI_FILE_DESCRIPTORS[0]=opened
DOMOPI_FILE_DESCRIPTORS[1]=opened
DOMOPI_FILE_DESCRIPTORS[2]=opened

unset DOMOPI_PUBLIC_FUNC_LIST
unset DOMOPI_PRIVATE_FUNC_LIST


# Internal use only
#
#	Make private function declaration (as C++, PHP, or other languages)
#	Private means "Not available as command"
#
#function private()
#{
#	DOMOPI_PRIVATE_FUNC_LIST="$DOMOPI_PRIVATE_FUNC_LIST $@"
#	return 0
#}

# Internal use only
# NOTE: Analogamente si poterbbe costruire una lista di funzioni definite public
# per avere automaticamente i "symbols" della API
function public()
{
	DOMOPI_PUBLIC_FUNC_LIST="$DOMOPI_PUBLIC_FUNC_LIST $@"
	return 0
}


#
#
# @author Andrea Tassotti
#
function trim() {
    local var="$*"
    var="${var#"${var%%[![:space:]]*}"}"   # remove leading whitespace characters
    var="${var%"${var##*[![:space:]]}"}"   # remove trailing whitespace characters
    echo -n "$var"
}


#
# @author Andrea Tassotti
#
function ltrim() {
    local var="$*"
    var="${var#"${var%%[![:space:]]*}"}"   # remove leading whitespace characters
    echo -n "$var"
}


#
# @author Andrea Tassotti
#
function rtrim() {
    local var="$*"
    var="${var%"${var##*[![:space:]]}"}"   # remove trailing whitespace characters
    echo -n "$var"
}


#
# @author Andrea Tassotti
#
function no_spaces()
{
    local var="$*"
	echo -n "${var/\ /}"
}


#
#
# @author Andrea Tassotti
#
function _get_file_descriptor()
{
	local i
	for((i=0;i<${#DOMOPI_FILE_DESCRIPTORS};i++))
	do
		if [[ ${DOMOPI_FILE_DESCRIPTORS[$i]} != 'opened' ]]
		then
			DOMOPI_FILE_DESCRIPTORS[$i]='opened'
			return $i
		fi
	done
	return 255
}


#
# $1 - file descriptor to release
#
# @author Andrea Tassotti
#
function _release_file_descriptor()
{
	DOMOPI_FILE_DESCRIPTORS[$1]='closed'
}


#
#
#	Restituisce una variabile DOMOPI_SCHEMA_<nome schema>
#	letta dal file contenente nomi colonne file
#	Restituisce anche DOMOPI_SCHEMA_NAME
#
#	$1 - File name
#	$2 - (optional)fingerprint schema extension
#
#	return file descriptor id or 255 if any error
#	
#
# @author Andrea Tassotti
#
#private domopi_file_open
function _domopi_file_open
{
	local SCHEMA
	unset DOMOPI_SCHEMA_NAME
	if [ ! -f "$1" ] ; then
		echo "FATAL: $1: No such file!" >&2
		return 255
	fi

	_get_file_descriptor
	fd=$?
	eval "exec $fd<> \"$1\""

	if [ $? -eq 0 ]; then
	# validate fingerprint
		IFS='$' read FINGERPRINT SCHEMA <&$fd
		if [ "$(rtrim $FINGERPRINT)" != "$DOMOPI_FILE_FINGERPRINT" ]
		then
			echo "FATAL: Not a DOMOPI file!" >&2
			echo $FINGERPRINT
			_domopi_file_close $fd
			return 255
		fi
		if [ -n "$2" ] && [ "$2" != "$SCHEMA" ]
		then
			echo "FATAL: Wrong DOMOPI $2 file!" >&2
			_domopi_file_close $fd
			return 255
		fi

		if [[ "$SCHEMA" != "ident" ]]; then
			IFS='#:' read -r -a DOMOPI_SCHEMA_$SCHEMA <&$fd
			if [ $? -ne 0 ]; then
				echo "FATAL: missing schema" >&2
				_domopi_file_close $fd
				return 255
			fi

			# Ribalta le informazioni in un array associativo
			unset DOMOPI_SCHEMA_COL_$SCHEMA
			declare -Ag DOMOPI_SCHEMA_COL_$SCHEMA
			local colIdx=0
			local DOMOPI_SCHEMA=$( eval echo \${DOMOPI_SCHEMA_$SCHEMA[@]} )
			for col in $DOMOPI_SCHEMA
			do
				eval "DOMOPI_SCHEMA_COL_$SCHEMA[$col]=$colIdx"
				colIdx=$((colIdx + 1))
			done

			DOMOPI_SCHEMA_NAME=$SCHEMA
		fi
	fi

	return $fd
}


#
#	$1 - file descriptor to close
#
# @author Andrea Tassotti
#
#private domopi_file_close
function _domopi_file_close
{
	# Solo se riposizioniamo le chiamate di domopi_file_close
	#unset DOMOPI_SCHEMA_$SCHEMA
	[ -n "$1" -a $1 -ne 255 ] && eval "exec $1>&-" && _release_file_descriptor $1
}


#
#
#	$1 - file descriptor 
#	$2 - token
#
# @author Andrea Tassotti
#
#private domopi_file_read_token
function _domopi_file_read_token()
{
	[ $# -lt 2 ] && return 3
	local TOKEN
	read TOKEN VALUE <&$1
	[ $TOKEN != "$2" ] && echo ERROR: unexpected token at line 2 >&2 && return 2
	return 0
}


#
# Get column numbert (position) from conf header
#
#	Read schema directly from file is useful for
#	backward schema compatibility
#	Return index in DOMOPI_CONF_FILE_COL_NUMBER
#
#	$1 - schema name
#	$2 - Column name
#
#	return 0 on succedd
#
# 
# @author Andrea Tassotti
#
#private domopi_column_by_name
function _domopi_column_by_name()
{
	if [ $# -eq 2 ]; then
		DOMOPI_CONF_FILE_COL_NUMBER=$( eval echo \${DOMOPI_SCHEMA_COL_$1[$2]} )
		echo $DOMOPI_CONF_FILE_COL_NUMBER
		return 0
	else
		echo FATAL: missing arguments >&2
		return 255
	fi
}


#
# Get next val for SEQUENTIAL type column
#
# 
# $1 - file name
# $2 - column (name)
# $3 - min (default 0)
# $4 - max (default 1000)
#
# @author Andrea Tassotti
#
#private domopi_seq_nextval
function _domopi_seq_nextval()
{
	[ -z "$DOMOPI_SCHEMA_NAME" ] && return 1

	_domopi_column_by_name "$DOMOPI_SCHEMA_NAME" "$2" >/dev/null
	[ -z "$DOMOPI_CONF_FILE_COL_NUMBER" ] && return 2

	local ACTUAL_ID_TMP=$(mktemp)
	local FULL_ID_TMP=$(mktemp)
	
	grep -v '^#' "$1" | cut -d: -f$((DOMOPI_CONF_FILE_COL_NUMBER + 1 ))| egrep '^[0-9]+$' | sort -g | tee >$ACTUAL_ID_TMP

	local maxid=$(tail -1 $ACTUAL_ID_TMP)

	if [ ${maxid:-0} -gt ${4:-1000} ]
	then
		echo 'Sequence exceed maximum' >&2 
		# cleanup
		rm $ACTUAL_ID_TMP $FULL_ID_TMP
		return
	fi
	seq $minid $((maxid + 1)) >	$FULL_ID_TMP
	nextid=$(join -v 1 $FULL_ID_TMP $ACTUAL_ID_TMP | head -1 )
	eval DOMOPI_${2^^}_COLUMN_NEXT_ID=$nextid
	echo $nextid

# cleanup
	rm $ACTUAL_ID_TMP $FULL_ID_TMP
}


#
#
#
#
#
function _domopi_desc()
{
	file=$1
	## Read schema
	_domopi_file_open "$file"
	fd=$?
	_domopi_file_close $fd

	echo "File  : $file"
	echo "Schema: $DOMOPI_SCHEMA_NAME"
	echo "Struct:"

	local i=1
	for key in  $( eval echo \${DOMOPI_SCHEMA_$DOMOPI_SCHEMA_NAME[@]} )
	do
		echo -en "   $i\t$key"
		case "$key" in
		*ID)
			echo -e "\tKEY, AUTO_INCREMENT"
			;;
		*U)
			echo -e "\tUNIQUE"
			;;
		*)
			echo ;;
		esac
		i=$((i+1))
	done

}



#
# Domopi conf file CRUD
#
#	$1   - File di configurazione contenente la tabella
#	$2-n - Colonne da visualizzare
#	$n-m - Clausole da rispettare
#
#	x Ã¨ considerato null
#
#	-v Verbose mode (invece che tabellare) esprimei nomi delle variabili impostate
#	-d<delim> Delimitatore per output tabellare (default)
#	-q  Sopprime intestazione colonne e indicazioni numero righe
#
#	Sintassi argomenti:
#	lista di nomi colonne per la select
#	lista coppie key=value per chiavi ricerca (AND)
#
#	Restituisce in STDOUT tabella nome=valore
#	e nel contempo imposta variabili DOMOPI_nome
#
#	NOTA: Ordine di output delle colonne corrisponde alla posizione nel file, non nell'ordine fornito in input funzione [TODO ?]
#
#	Esempio:
#
#	Match diretto
#	_domopi_select_row global.cfg currentstate sensorID=1
#	Consente uso espressioni regolari:
#	_domopi_select_row global.cfg currentstate descriptionU=Luce.*alta
#
function _domopi_select_row()
{
	local VERBOSE=false
	DELIMITER="\t"
	HEADER=true
	FOOTER=true

	[ -z "$DOMOPI_SCHEMA_NAME" ] && return 1

	# Processa opzioni locali
	local OPTIND=1 OPTARG opt
	while getopts "d:qv" opt; do
		case $opt in
		v)	VERBOSE=true ; HEADER=false ;;
		q)	HEADER=false ; FOOTER=false ;;
		d)	DELIMITER="$OPTARG" ;;
		:)	echo argument required ; return ;;
		esac
	done
	shift $((OPTIND-1))

	file=$1
	shift
	declare -A where
	declare -A columns

	local position=0

	for a in "$@"
	do
		# ricerca = per creare criterio ricerca
		if [[ "$a" =~ .*=.* ]]; then
			key="${a%%=*}"
			value="${a##*=}"
			where[$key]=$value
		else
			unset DOMOPI_$a
			columns[$a]=$position
			position=$((position+1))
		fi
	done

	local row_to_match=""

	for key in  $( eval echo \${DOMOPI_SCHEMA_$DOMOPI_SCHEMA_NAME[@]} )
	do
		if [ -n "${where[$key]}" ]
		then
			row_to_match="$row_to_match${where[$key]}:"
		else
			row_to_match="${row_to_match}.*:"
		fi
	done
	# Trim : right
	row_to_match=${row_to_match%"${row_to_match##*[!:]}"}

	local cut_fields=""
	local column_reduced=0
	declare -a columns_to_show

	for key in  $( eval echo \${DOMOPI_SCHEMA_$DOMOPI_SCHEMA_NAME[@]} )
	do
		if [ -n "${columns[$key]}" ]
		then
			_domopi_column_by_name $DOMOPI_SCHEMA_NAME $key >/dev/null
			cut_fields="${cut_fields}$((DOMOPI_CONF_FILE_COL_NUMBER+1)),"
			columns_to_show[$column_reduced]=$key
			column_reduced=$((column_reduced+1))
		fi
	done

	# rtrim ,
	cut_fields=${cut_fields%"${cut_fields##*[!,]}"}

	# Prepariamo ordinamennto output
	declare -a posizioni
	for col in ${!columns[@]}
	do
		pos=${columns[$col]}
		posizioni[$pos]=$col
	done

	local _TMP=$(mktemp)
	# 
	# NOTA: cut non riordina i campi estratti
	if [ -n "$cut_fields" ] ; then
		local i=0
		local pos row
		local colname

		local SPOOL=$(mktemp)


		if $HEADER; then
		echo
		for pos in ${!posizioni[@]}
		do
			echo -ne "${posizioni[$pos]}$DELIMITER"
		done
		echo
		echo 
		fi	> $SPOOL

		# Impossibile costrutto pipe: deve generare variabili globali
		egrep "$row_to_match" "$file" | cut -d: -f$cut_fields > $_TMP
		while read row
		do
			IFS=: read -a row <<< "$row"
			local c=0
			c=0

			# Output ordinato
			for pos in ${!posizioni[@]}
			do
				colname=${posizioni[$pos]}	
				local index
				# Index of value
				for idx in ${!columns_to_show[@]}
				do
					[ ${columns_to_show[$idx]} == $colname ] && index=$idx && break
				done
				$VERBOSE && echo -n $colname[$i]=

				# Per columns occorre che un campo sia non vuoto
				[ -n "${row[$index]}" ] && echo -ne ${row[$index]} || echo -ne ' '
				! $VERBOSE && echo -ne "$DELIMITER"
				$VERBOSE && echo
				eval DOMOPI_$colname\[$i\]=\"\$\{row[$index]\}\"
				c=$((c+1))
			done

			i=$((i+1))
			echo
		done < $_TMP >>$SPOOL

		$FOOTER && echo "$i row(s) selected." >>$SPOOL
		column -t -s $'\t' $SPOOL
	fi

	rm -f $_TMP $SPOOL

	return 0
}


#
# Domopi conf file CRUD
#
#	Inserisce una riga nel file indicato
#	rispettando il suo schema.
#	In argomento sono passate coppie chiave valore;
#	se la chiave coincide con lo schema allora viene
#	inserita (altrimenti viene silentemente ignorata).
#	Le colonne auto-increment devono esprimere un valore *;
#	sono autoincrement solo le colonne il cui nome termina con ID.
#	Sono invece univoche le colonne che terminano con U.
#	Si ricordi che i nomi di colonna sono minuscoli, quindi
#	il suffisso maiuscolo Ã¨ un tipo/caratteristica
#
#	$1 - File di configurazione contenente la tabella
#	$@ - lista coppie key:value per i valori
#
#
function _domopi_insert_row()
{
	[ -z "$DOMOPI_SCHEMA_NAME" ] && return 1

	file=$1
	shift

	declare -A values
	local a

	for a in "$@"
	do
		key="${a%%:*}"
		value="${a##*:}"
		if [[ "$key" =~ ID$ ]] && [ "$value" = '*' ]
		then
			value=$( _domopi_seq_nextval "$file" "$key" )
		fi

		# Deve rispettare univocitÃ  delle colonne che finiscono con U
		if [[ "$key" =~ U$ ]]
		then
			echo _domopi_column_by_name "$DOMOPI_SCHEMA_NAME" "$key" >/dev/null
			_domopi_column_by_name "$DOMOPI_SCHEMA_NAME" "$key" >/dev/null
			if grep -v '^#' "$file" | cut -d: -f$DOMOPI_CONF_FILE_COL_NUMBER | grep "$value" >/dev/null
			then
				echo WARNING: duplicate value $value in column $key >&2
				return 255
			fi
		fi

		values[$key]=$value
	done

	
	local row=""
	local _TMP=$(mktemp)
	eval echo \${DOMOPI_SCHEMA_$DOMOPI_SCHEMA_NAME[@]} >$_TMP
	while read -d ' ' key
	do
		if [ -n "${values[$key]}" ]
		then
			value="${values[$key]}"
		else
			value=
			[[ "$key" =~ ID$ ]] && value=x
		fi
		row="$row$value:"
	done <$_TMP

	echo "$row" >>"$file"

	return 0
}


##
#	Rimozione di righe in file di configurazione
#
# Domopi conf file CRUD
#
#	$1 - File di configurazione contenente la tabella
#	$@ - lista coppie key=value per chiavi ricerca (AND)
#	$? - 0 = cancellazione avvenuta, 1 = cancellazione non avvenuta, 255 = errore nella gestione file
#
function _domopi_delete_row()
{
	local VERBOSE=false

	[ -z "$DOMOPI_SCHEMA_NAME" ] && return 1

	# Processa opzioni locali
	local OPTIND=1 OPTARG opt
	while getopts ":v" opt; do
		case $opt in
		v)	VERBOSE=true ;;
		:)	echo argument required ; return ;;
		esac
	done
	shift $((OPTIND-1))

	file=$1
	shift
	declare -A where

	for a in "$@"
	do
		# ricerca = per criterio ricerca
		if [[ "$a" =~ .*=.* ]]; then
			key="${a%%=*}"
			value="${a##*=}"
			# Il criterio deve essere espresso (sicurezza)
			[ -n "$value" ] && where[$key]=$value
		fi
	done

	# Non ci sono clausole di ricerca
	[ ${#where[@]} -eq 0 ] && return 1

	local row_to_match=""
	
	for key in  $( eval echo \${DOMOPI_SCHEMA_$DOMOPI_SCHEMA_NAME[@]} )
	do
		if [ -n "${where[$key]}" ]
		then
			row_to_match="$row_to_match${where[$key]}:"
		else
			row_to_match="${row_to_match}.*:"
		fi
	done
	# Trim : right
	row_to_match=${row_to_match%"${row_to_match##*[!:]}"}


	local _TABLE=$(mktemp)
	local row local row_number
	local rows_deleted=0
	local ARGS=""
	grep -n "$row_to_match" "$file" >$_TABLE
	while read row
	do
		row_number=${row%%:*}
		# Accumula riga di configurazione sed
		if [ $row_number -gt 2 ]; then
			ARGS="${ARGS}-e \"${row_number}d\" "
			rows_deleted=$((rows_deleted+1))	
		fi
	done < $_TABLE

	# Solo se non match con intestazione
	if [[ $rows_deleted -gt 0 ]]; then
		eval sed -i.bak $ARGS "$file"
	fi
	$VERBOSE && echo "$rows_deleted row(s) deleted."

	rm -f $_TABLE

	[[ $rows_deleted -gt 0 ]] && return 0
	return 1
}



#
# Domopi conf file CRUD
#
#	$1 - File di configurazione contenente la tabella
#	$@ lista coppie key:value per i valori da impostare,  lista coppie key=value per chiavi ricerca (AND)
#	$? - 0 = aggiornamento avvenuto, 1 = aggiornamento non avvenuto, 255 = errore nella gestione file
#
function _domopi_update_row()
{
	local VERBOSE=false

	[ -z "$DOMOPI_SCHEMA_NAME" ] && return 1

	# Processa opzioni locali
	local OPTIND=1 OPTARG opt
	while getopts ":v" opt; do
		case $opt in
		v)	VERBOSE=true ;;
		:)	echo argument required ; return ;;
		esac
	done
	shift $((OPTIND-1))

	file=$1
	shift
	declare -A where
	declare -A columns

	for a in "$@"
	do
		# ricerca = per criterio ricerca
		if [[ "$a" =~ .*=.* ]]; then
			key="${a%%=*}"
			value="${a##*=}"
			where[$key]="$value"
		fi
		# ricerca : per set
		if [[ "$a" =~ .*:.* ]]; then
			key="${a%%:*}"
			value="${a##*:}"
			if ! [[ "$key" =~ ID$ ]]; then
				columns[$key]="$value"
			fi
		fi
	done

	# Non ci sono clausole di ricerca
	[ ${#where[@]} -eq 0 ] && return 1

	local row_to_match=""
	local row_as_is=""

	for key in	$( eval echo \${DOMOPI_SCHEMA_$DOMOPI_SCHEMA_NAME[@]} )
	do
		if [ -n "${where[$key]}" ]
		then
			row_to_match="$row_to_match${where[$key]}:"
		else
			row_to_match="${row_to_match}.*:"
		fi
	done
	# Trim : right
	row_to_match=${row_to_match%"${row_to_match##*[!:]}"}

	local _TABLE=$(mktemp)
	local ARGS=""
	local row row_number row_as_is row_to_be
	local rows_updated=0
	egrep -n "$row_to_match" "$file" >$_TABLE

	while read row
	do
		row_number=${row%%:*}
		row_as_is=${row#*:}

		IFS=: read -r -a row_data <<< "$row_as_is"

		# Calcola offset compreso header
		local row_to_be=""
		for key in	$( eval echo \${DOMOPI_SCHEMA_$DOMOPI_SCHEMA_NAME[@]} )
		do
			if [ -n "${columns[$key]}" ]
			then
				row_to_be="$row_to_be${columns[$key]}:"
			else
				# Deve recuperare il vero dato
				_domopi_column_by_name "$DOMOPI_SCHEMA_NAME" "$key" >/dev/null
				dato=${row_data[$DOMOPI_CONF_FILE_COL_NUMBER]}
				row_to_be="${row_to_be}$dato:"
			fi
		done

		# Accumula riga di configurazione sed
		if [ $row_number -gt 2 ]; then
			ARGS="${ARGS}-e \"${row_number}c$row_to_be\" "
			rows_updated=$((rows_updated+1))	
		fi
	done < $_TABLE


	# Solo se non match con intestazione
	if [[ $rows_updated -gt 0 ]]; then
		eval sed -i.bak $ARGS "$file"
	fi
	$VERBOSE && echo "$rows_updated row(s) updated."

	rm -f $_TABLE

	[[ $row_updated -gt 0 ]] && return 0
	return 1
}

#
# PROPOSAL:
#
#	Directory API extensions to autoload
#


#-----------------------------------------------
# Begin-of-API
#-----------------------------------------------

# NOTA GENERALE: le funzioni (proprie) con un output
#		avranno in realtÃ  un doppio output (oltre exit code).
#		Uno a STDOUT e uno con variabile pari a DOMOPI_RESULT
#		oppure ad un nome semanticamente collegato alla funzione
#		e con prefisso DOMOPI_
#

##
#
#
public domopi_help
function domopi_help
{
	echo "API Public functions:"
	echo
	for f in $DOMOPI_PUBLIC_FUNC_LIST
	do
		echo -e "\t$f()"
	done
	echo
	echo "Use domopi_man <function_name> for details"
}

##
#
#	@see bashdoc
#
public domopi_man
function domopi_man
{
/usr/bin/awk '
/^##/				{ incomment=1; insummary=1; text=""; getline; }
/^#[[:blank:]]*$/	{ insummary=0; getline; }
/^#[[:blank:]]*[\-][a-zA-Z]+/ { if (incomment) { insummary=0; par=""; for(i=2;i<=NF;i++) par=par" "$i; o[$2]=par; next; } }
/^#[[:blank:]]*[\@]author/ { if (incomment) { insummary=0; author=""; for(i=3;i<=NF;i++) author=author$i" "; next; } }
/^#[[:blank:]]*[\@]note/ { if (incomment) { insummary=0; n=""; for(i=3;i<=NF;i++) n=n$i" "; note[length(note)]=n; next; } }
/^#[[:blank:]]*[\@]see/ { if (incomment) { insummary=0; s=""; for(i=3;i<=NF;i++) s=s$i" "; see[length(see)]=s; next; } }
/^#.*[\$][0-9\?]+/	{ if (incomment) { par=""; for(i=2;i<=NF;i++) par=par" "$i; h[$2]=par; next; } }
/^function /		{ if ( incomment && $2 == "'"$1()"'" ) { print "Funzione   : "$2; print "Sommario   : "summary; print "Descrizione: "text; print "Autore     : "author; for(v in note) print "Nota       : "note[v]; for(v in see) print "Vedi       : "see[v]; print "Parametri  :"; for(v in h) print h[v]; print "Opzioni    :"; for(v in o) print o[v]    ; print ""; } incomment=0; delete h; delete o; delete note; delete see; getline; }
					{ if ( incomment ) { if ( insummary ) { summary=""; for(i=2;i<=NF;i++) summary=summary$i" "; } else { for(i=2;i<=NF;i++) text=text$i" "; } } } ' $DOMOPI_API_PATH
}


##
#	Avvia timer per tracciamento durata operazione
#
#	$1 - (opzionale) Nome del timer
#
#	@author	Andrea Tassotti
#
function domopi_timer_start()
{
	declare -g DOMOPI_OP_START_TIME_$1
	eval DOMOPI_OP_START_TIME_$1=$( date '+%s%N' )
}


##
#	Mostra tempo impiegato da operazione in msec
#
#	$1 - (opzionale) Nome del timer
#
#	@author	Andrea Tassotti
#
function domopi_time_elapsed()
{
	PROMPT=
	[[ "$1" = '-q' ]] && PROMPT=-q && shift
	DOMOPI_OP_END_TIME=$( date '+%s%N' )
	eval START=\$DOMOPI_OP_START_TIME_$1
	[ -z "$DOMOPI_OP_START_TIME_$1" ] && return 1
	time=$( echo "( $DOMOPI_OP_END_TIME - $START ) / 1000000" | bc )
	domopi_notice $PROMPT "Operazione '${1:-anonymous}' conclusa in $time msec"
}


##
#
#
#
function domopi_notice()
{
	PROMPT=true
	[[ "$1" = '-q' ]] && PROMPT=false && shift
	echo
	echo $@
	if $PROMPT; then
		echo 'Premi invio per proseguire'
		read
	fi
}


##
#	getIdentity
#
#	$1 - filter component (ident, uuid, created)
#
#	$? - file descriptor or 255 on error
#
#	@author Andrea Tassotti
#
function domopi_ident()
{
	_domopi_file_open $DOMOPI_IDENT_FILE
	fd=$?

	if [ $fd -ne 255 ]
	then
		_domopi_file_read_token $fd 'ident:' && DOMOPI_IDENT_IDENT=$VALUE &&
		_domopi_file_read_token $fd 'uuid:' && DOMOPI_IDENT_UUID=$VALUE &&
		_domopi_file_read_token $fd 'created:' && DOMOPI_IDENT_CREATED=$VALUE &&
		# global/external command use
		echo $DOMOPI_IDENT_IDENT $DOMOPI_IDENT_UUID $DOMOPI_IDENT_CREATED
		_domopi_file_close $fd
	fi
	
	return 1
}




##
#	Crea identitÃ  e file di configurazioni
#
#	Da utilizzare una sola volta nel ciclo di vita del
#	sistema per creare i file di configurazione richiesti.
#
#	$1 -	Identity	
#
#	@note ATTENZIONE! Operazione irreversibile
#	@author Andrea Tassotti
#
public domopi_init
function domopi_init()
{
	if [ -z "$1" ]
	then
		echo "ERROR: identity missing." >&2
		return 1
	fi

	# Generate Identity file

	# generate uuid
	if [ -x /usr/bin/uuidgen ]; then
		UUID=$(/usr/bin/uuidgen)
	else # less accurate uuid
		UUID=$(printf %04x%04x-%04x-%04x-%04x-%04x%04x%04x $RANDOM $RANDOM $RANDOM $RANDOM $RANDOM $RANDOM $RANDOM $RANDOM )
	fi
	echo "$DOMOPI_FILE_FINGERPRINT" '$ident$' >$DOMOPI_IDENT_FILE
	echo "ident: $1" >>$DOMOPI_IDENT_FILE
	echo "uuid: $UUID" >>$DOMOPI_IDENT_FILE
	echo "created: $(date +%s)" >>$DOMOPI_IDENT_FILE

	# Generate global configuration file (empty with schema)
	echo "$DOMOPI_FILE_FINGERPRINT" '$global$' >$DOMOPI_GLOBAL_CONF
	echo "${DOMOPI_FILE_SCHEMA['global']}" >>$DOMOPI_GLOBAL_CONF

	return 0
}


##
#	Creazione configurazione oggetti di base
#
#	Ancora incompleto.
#	Scrive nel file determinato dalla variabile
#	ambientale DOMOPI_GLOBAL_CONF creato con
#	domopi_init
#
#	$1 - 'sensor', 'module' or 'group'
#	$2 - name
#
#	-m moduleid TODO
#	-g groupid TODO
#	-w wiredPI TODO
#	-s default state TODO
#	-i <patchIn>
#	-o <patchOut>
#
#	@author Andrea Tassotti
#
public domopi_create
function domopi_create()
{
	local VERBOSE=false
	local PATCH
	local ret
	# Il file di configurazione deve esistere inizializzato
	# Read schema
	_domopi_file_open "$DOMOPI_GLOBAL_CONF"
	fd=$?	# Non usato direttamente
	[ $fd -eq 255 ] && return 1

	# Processa opzioni locali
	local OPTIND=1 OPTARG opt
	while getopts ":vi:o:" opt; do
		case $opt in
		v)	VERBOSE=true ;;
		i)	PATCH="patchin:$OPTARG" ;;
		o)	PATCH="patchout:$OPTARG" ;;
		:)	echo argument required ; return ;;
		esac
	done
	shift $((OPTIND-1))

	case "$1" in
	sensor)
		_domopi_insert_row "$DOMOPI_GLOBAL_CONF" sensorID:'*' "descriptionU:$2" "$PATCH"
		ret=$?
		;;
	group)
		_domopi_insert_row "$DOMOPI_GLOBAL_CONF" groupID:'*' "descriptionU:$2"
		ret=$?
		;;
	*)
		echo FATAL: not implemented >&2
		return 1
		;;
	esac

	[ $fd -eq 255 ] && return 255	
	_domopi_file_close $fd

	return $ret
}


##
#	Distruzione di un oggetto di configurazione
#
#	Il criterio di ricerca Ã¨ una espressione regolare
#	sulla descrizione dell'oggetto. Utilizzare -n
#	per utilizzare un criterio basato su ID numerico.
#
#	$1 - Tipo oggetto
#	$2 - Criterio di ricerca
#	-n - Criterio di ricerca numerico
#
#	@author Andrea Tassotti
#
public domopi_destroy
function domopi_destroy()
{
	local VERBOSE=false
	local NUMERIC=false
	# Il file di configurazione deve esistere inizializzato
	# Read schema
	_domopi_file_open "$DOMOPI_GLOBAL_CONF"
	fd=$?	# Non usato direttamente
	[ $fd -eq 255 ] && return 1

	# Processa opzioni locali
	local OPTIND=1 OPTARG opt
	while getopts ":vn" opt; do
		case $opt in
		v)	VERBOSE=true ;;
		n)	NUMERIC=true ;;
		:)	echo argument required ; return ;;
		esac
	done
	shift $((OPTIND-1))
	case "$1" in
	sensor)
		if $NUMERIC ; then
			_domopi_delete_row $DOMOPI_GLOBAL_CONF sensorID="$2"
			ret=$?
		else
			_domopi_delete_row $DOMOPI_GLOBAL_CONF descriptionU="$2"
			ret=$?
		fi
		if [ $ret -eq 0 ]; then
			echo "Oggetto cancellato correttamente"
		else
			echo "Nessun oggetto cancellabile"
		fi
		;;
	*)
		echo FATAL: not implemented >&2
		return 1
		;;
	esac

	return 0
}



#
#	$1 - sensorID
#	$2 - New state
#
# TODO: Supportare gruppi e moduli
#
#	@author Andrea Tassotti
#
function _domopi_do_transition_by_id()
{
	_domopi_select_row -q "$DOMOPI_GLOBAL_CONF" currentstate patchin sensorID=$1 >/dev/null

	# No transition
	[[ $2 = ${DOMOPI_currentstate[0]} ]] && return 1

	# No propagation
	[ -z "${DOMOPI_patchin[0]}" ] && return 0

	# Propagation
	echo propagation
	_domopi_select_row -q "$DOMOPI_GLOBAL_CONF" sensorID patchout=${DOMOPI_patchin[0]} > /dev/null

	# TODO: Divenga _domopi_where_in	
	in=$( echo ${DOMOPI_sensorID[@]} | tr ' ' '|' )
	echo propaga transizione $2 ai sensori ${DOMOPI_sensorID[@]}
	_domopi_update_row -v "$DOMOPI_GLOBAL_CONF" currentstate:$2 moduleID=x sensorID=$in

	return 0
}


#
#	$1 - description
#	$2 - New state
#
# TODO: Supportare gruppi e moduli
#
#	@author Andrea Tassotti
#
function _domopi_do_transition_by_name()
{
	_domopi_select_row -q "$DOMOPI_GLOBAL_CONF" currentstate patchin $criptionU >/dev/null

	# No transition
	[[ $2 = ${DOMOPI_currentstate[0]} ]] && return 1

	# No propagation
	[ -z "${DOMOPI_patchin[0]}" ] && return 0

	# Propagation
	echo propagation
	_domopi_select_row -q "$DOMOPI_GLOBAL_CONF" sensorID patchout=${DOMOPI_patchin[0]} > /dev/null

	# TODO: Divenga _domopi_where_in	
	in=$( echo ${DOMOPI_sensorID[@]} | tr ' ' '|' )
	echo propaga transizione $2 ai sensori ${DOMOPI_sensorID[@]}
	_domopi_update_row -v "$DOMOPI_GLOBAL_CONF" currentstate:$2 moduleID=x sensorID=$in

	return 0
}



##
#	Imposta stato di un sensore o un gruppo di sensori
#
#	$1 - Criterio di ricerca
#	$2 - New state
#	-g - Il criterio di ricerca si riferisce ad un gruppo
#	-n - Usa criterio di ricerca numerico (ID) invece che espressione regolare su descrizione
#
#	Non forza uso di alcun tipo (puo' essere numerico o alfanumerico)
#	Un valore vuoto per lo stato non cancella lo stato corrente: se
#	il sensore appartiene ad un gruppo eredita lo stato dal gruppo
#	(il primo se appartiene a piÃ¹ gruppi)
#	Aggiorna gli stati di tutti i sensori con patchout pari al patchin
#	del sensore su cui Ã¨ applicato
#
#
#	TODO: Implementare selettore per modulo e gruppo
#
#	Esempio: domopi_set_state 1 on
#
#	@author Andrea Tassotti
#
public domopi_set_state
function domopi_set_state()
{
	local NUMERIC=false
	local GROUP=false
	local ret=1
	# Il file di configurazione deve esistere inizializzato
	# Read schema
	_domopi_file_open "$DOMOPI_GLOBAL_CONF"
	fd=$?	# Non usato direttamente
	[ $fd -eq 255 ] && return 1

	# Processa opzioni locali
	local OPTIND=1 OPTARG opt
	while getopts ":gn" opt; do
		case $opt in
		g)	GROUP=true ;;
		n)	NUMERIC=true ;;
		:)	echo argument required ; return ;;
		esac
	done
	shift $((OPTIND-1))

	if $GROUP ; then
		if $NUMERIC ; then
			echo group numeric
			#_domopi_update_row "$DOMOPI_GLOBAL_CONF" currentstate:$2 moduleID=x groupID=$1
		else
			echo group description
			#_domopi_update_row "$DOMOPI_GLOBAL_CONF" currentstate:$2 moduleID=x sensorID=x descriptionU="$1"
		fi
		# TODO: cercare tutti i sensori che appartengono al gruppo
		#       e impostarelo stesso stato
	else
# TODO: se $2 Ã¨ vuoto, occorre cercare stato del groupID primario per il
# sensore
		if $NUMERIC ; then
			_domopi_do_transition_by_id $1 $2
			ret=$?
			[ $ret -eq 0 ] && _domopi_update_row "$DOMOPI_GLOBAL_CONF" currentstate:$2 moduleID=x sensorID=$1
		else
			_domopi_do_transition_by_name $1 $2
			ret=$?
			[ $ret -eq 0 ] && _domopi_update_row "$DOMOPI_GLOBAL_CONF" currentstate:$2 moduleID=x groupID=x descriptionU="$1"
		fi
	fi

	#[ $fd -eq 255 ] && return 255	
	_domopi_file_close $fd
	return $ret
}



##
#	Legge stato di un sensore o gruppo
#
#	$1 - Criterio di ricerca
#	-g - Il criterio di ricerca si riferisce ad un gruppo
#	-n - Usa criterio di ricerca numerico (ID) invece che espressione regolare su descrizione
#
#	Restituisce lo stato in STDOUT (potendo essere anche alfanumerico)
#	Distribuito anche come ${DOMOPI_currentstate[0]}
#	Possibile avere elenco stati piÃ¹ oggetti secriterio non selettivo
#	Non forza uso di alcun tipo (ouo' essere numerico o alfanumerico)
#
#
#	Esempio: domopi_set_state 1 off
#
#
#	TODO: Implementare selettore per modulo e gruppo
#
#	@author Andrea Tassotti
#
public domopi_get_state
function domopi_get_state()
{
	local NUMERIC=false
	local GROUP=false
	# Il file di configurazione deve esistere inizializzato
	# Read schema
	_domopi_file_open "$DOMOPI_GLOBAL_CONF"
	fd=$?	# Non usato direttamente
	[ $fd -eq 255 ] && return 1

	# Processa opzioni locali
	local OPTIND=1 OPTARG opt
	while getopts ":gn" opt; do
		case $opt in
		g)	GROUP=true ;;
		n)	NUMERIC=true ;;
		:)	echo argument required ; return ;;
		esac
	done
	shift $((OPTIND-1))

	if $GROUP ; then
		if $NUMERIC ; then
			_domopi_select_row -q "$DOMOPI_GLOBAL_CONF" currentstate groupID=$1
		else
			_domopi_select_row -q "$DOMOPI_GLOBAL_CONF" currentstate sensorID=x descriptionU="$1"
		fi
	else
		if $NUMERIC ; then
			_domopi_select_row -q "$DOMOPI_GLOBAL_CONF" currentstate sensorID=$1
		else
			_domopi_select_row -q "$DOMOPI_GLOBAL_CONF" currentstate groupID=x descriptionU="$1"
		fi
	fi

	#[ $fd -eq 255 ] && return 255	
	_domopi_file_close $fd
	return 0
}


##
# Lista degli oggetti di configurazioni selezionati per tipo
#
#	$1 - Tipo (sensor, module, group, ...)
#
#	Indica ID, descrizione e stato
#
#	@author Andrea Tassotti
#
public domopi_list
function domopi_list()
{
	## Read schema
	_domopi_file_open "$DOMOPI_GLOBAL_CONF"
	fd=$?	# Non usato direttamente

	case "$1" in
	sensor)
		_domopi_select_row "$DOMOPI_GLOBAL_CONF" sensorID descriptionU currentstate patchin patchout groupID=x
		;;
	group)
		_domopi_select_row groupID descriptionU currentstate sensorID=x
		;;
	*)
		echo NON IMPLEMENTATO
		;;
	esac

	#[ $fd -eq 255 ] && return 255	
	_domopi_file_close $fd
}



#-----------------------------------------------
# End-of-API
#-----------------------------------------------

# Make private internal function
#
for f in $DOMOPI_PRIVATE_FUNC_LIST
do
	echo DEBUG. unsetting $f
	unset $f
done
unset private
unset $DOMOPI_PRIVATE_FUNC_LIST


#
# Esempi d'uso
#-----------------------------

# ./domopi.functions   # NON ESEGUE !
# . domopi.functions   # include la libreria
# 
# Sono diponibili come comandi (quindi anche come funzioni se incluso in un ulteriore script)
# le sole funzioni non dichiarate private.
# 
# Quindi possiamo scrivere:
# 
# domopi_ident
# 
# e ottenere a STDOUT l'identitÃ  (per un uso interattivoi e quindi feedback utente) 
# 
# oppure usare 
# 
# domopi_ident >/dev/null
# 
# per utilizzare solo la variabile DOMOPI_IDENT (uso interno ad uno script, senza over utilizzare costrutti per leggere stdout in variabile).
# 
# Il passaggio argomenti Ã¨ ovviamente consentito come per ogni funzione bash.
# 

