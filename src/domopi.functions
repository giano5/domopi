#!/bin/false
#	La prima riga impedisce di essere utilizzato come programma.
#	E' solo una libreria.
#
# DomoPI API
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation, either version 3 of the License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
#    Copyrights (C) 2016 
#
#	 @date:
#	 @version:
#

# Global variables

# Production
#DOMOPI_CONF_PATH=/usr/local/etc/
# Development
DOMOPI_CONF_PATH=.

# Production
#DOMOPI_CONF_TEMPLATE_PATH=/usr/local/var/lib/domopi
# Development
DOMOPI_CONF_TEMPLATE_PATH=.

# Production
#DOMOPI_BIN_PATH=/usr/local/bin
# Development
DOMOPI_BIN_PATH=.

# Percorso istallazione di questo file (ad uso interno)
# Production
#DOMOPI_API_PATH=/usr/local/libexec/domopi.functions
# Development
DOMOPI_API_PATH=domopi.functions


if [ -d "$DOMOPI_CONF_PATH/domopi.d" ]; then
	DOMOPI_EXTENDED_CONF_PATH=$DOMOPI_CONF_PATH/domopi.d/
else
	DOMOPI_EXTENDED_CONF_PATH=$DOMOPI_CONF_PATH
fi

# Requisiti
DOMOPI_REQUIRES="awk bc cut egrep grep sed tr"

declare -A DOMOPI_FILE_SCHEMA

# Configuration files
DOMOPI_CONF_EXTENTION=cfg
DOMOPI_IDENT_FILE=$DOMOPI_CONF_PATH/ident.$DOMOPI_CONF_EXTENTION
DOMOPI_GLOBAL_CONF=$DOMOPI_CONF_PATH/global.$DOMOPI_CONF_EXTENTION
DOMOPI_MODULES_CONF=modules.$DOMOPI_CONF_EXTENTION

DOMOPI_FILE_FINGERPRINT='# Automatically generatedfile: do not modify!'

# Schemas is for generate initial configuration

# Logical configuration
DOMOPI_FILE_SCHEMA['global']='# groupID:device:sensorID:patchin:patchout:wiredpi:type:mode:maxexecutiontime:order:currentstate:descriptionU:alias:groups'
# NOTA: In caso di bash < 4.2 dichiarare a questo livello
#declare -A DOMOPI_SCHEMA_COL_global

# Physical configuration
DOMOPI_FILE_SCHEMA['modules']='# modulename:defaultstate:inverse:wiredpi:type:used'
# NOTA: In caso di bash < 4.2 dichiarare a questo livello
#declare -A DOMOPI_SCHEMA_COL_modules

unset DOMOPI_FILE_DESCRIPTORS
declare -a DOMOPI_FILE_DESCRIPTORS
# Declare standard opened
DOMOPI_FILE_DESCRIPTORS[0]=opened
DOMOPI_FILE_DESCRIPTORS[1]=opened
DOMOPI_FILE_DESCRIPTORS[2]=opened

unset DOMOPI_PUBLIC_FUNC_LIST
unset DOMOPI_PRIVATE_FUNC_LIST


# Internal use only
#
#	Make private function declaration (as C++, PHP, or other languages)
#	Private means "Not available as command"
#
#function private()
#{
#	DOMOPI_PRIVATE_FUNC_LIST="$DOMOPI_PRIVATE_FUNC_LIST $@"
#	return 0
#}

# Internal use only
# NOTE: Analogamente si poterbbe costruire una lista di funzioni definite public
# per avere automaticamente i "symbols" della API
function public()
{
	DOMOPI_PUBLIC_FUNC_LIST="$DOMOPI_PUBLIC_FUNC_LIST $@"
	return 0
}


#
#
# @author Andrea Tassotti
#
function trim() {
    local var="$*"
    var="${var#"${var%%[![:space:]]*}"}"   # remove leading whitespace characters
    var="${var%"${var##*[![:space:]]}"}"   # remove trailing whitespace characters
    echo -n "$var"
}


#
# @author Andrea Tassotti
#
function ltrim() {
    local var="$*"
    var="${var#"${var%%[![:space:]]*}"}"   # remove leading whitespace characters
    echo -n "$var"
}


#
# @author Andrea Tassotti
#
function rtrim() {
    local var="$*"
    var="${var%"${var##*[![:space:]]}"}"   # remove trailing whitespace characters
    echo -n "$var"
}


#
# @author Andrea Tassotti
#
function no_spaces()
{
    local var="$*"
	echo -n "${var/\ /}"
}


#
#
# @author Andrea Tassotti
#
function _get_file_descriptor()
{
	local i
	for((i=0;i<${#DOMOPI_FILE_DESCRIPTORS};i++))
	do
		if [[ ${DOMOPI_FILE_DESCRIPTORS[$i]} != 'opened' ]]
		then
			DOMOPI_FILE_DESCRIPTORS[$i]='opened'
			return $i
		fi
	done
	return 255
}


#
# $1 - file descriptor to release
#
# @author Andrea Tassotti
#
function _release_file_descriptor()
{
	DOMOPI_FILE_DESCRIPTORS[$1]='closed'
}


#
#
#	Restituisce una variabile DOMOPI_SCHEMA_<nome schema>
#	letta dal file contenente nomi colonne file
#	Restituisce anche DOMOPI_SCHEMA_NAME
#
#	$1 - File name
#	$2 - (optional)fingerprint schema extension
#
#	return file descriptor id or 255 if any error
#	
#
# @author Andrea Tassotti
#
#private domopi_file_open
function _domopi_file_open
{
	local SCHEMA
	unset DOMOPI_SCHEMA_NAME
	if [ ! -f "$1" ] ; then
		echo "FATAL: $1: No such file!" >&2
		return 255
	fi

	_get_file_descriptor
	fd=$?
	eval "exec $fd<> \"$1\""

	if [ $? -eq 0 ]; then
	# validate fingerprint
		IFS='$' read FINGERPRINT SCHEMA <&$fd
		if [ "$(rtrim $FINGERPRINT)" != "$DOMOPI_FILE_FINGERPRINT" ]
		then
			echo "FATAL: Not a DOMOPI file!" >&2
			echo $FINGERPRINT
			_domopi_file_close $fd
			return 255
		fi
		if [ -n "$2" ] && [ "$2" != "$SCHEMA" ]
		then
			echo "FATAL: Wrong DOMOPI $2 file!" >&2
			_domopi_file_close $fd
			return 255
		fi

		if [[ "$SCHEMA" != "ident" ]]; then
			IFS='#:' read -r -a DOMOPI_SCHEMA_$SCHEMA <&$fd
			if [ $? -ne 0 ]; then
				echo "FATAL: missing schema" >&2
				_domopi_file_close $fd
				return 255
			fi

			# Ribalta le informazioni in un array associativo
			unset DOMOPI_SCHEMA_COL_$SCHEMA
			declare -Ag DOMOPI_SCHEMA_COL_$SCHEMA
			local colIdx=0
			local DOMOPI_SCHEMA=$( eval echo \${DOMOPI_SCHEMA_$SCHEMA[@]} )
			for col in $DOMOPI_SCHEMA
			do
				eval "DOMOPI_SCHEMA_COL_$SCHEMA[$col]=$colIdx"
				colIdx=$((colIdx + 1))
			done

			DOMOPI_SCHEMA_NAME=$SCHEMA
		fi
	fi

	return $fd
}


#
#	$1 - file descriptor to close
#
# @author Andrea Tassotti
#
#private domopi_file_close
function _domopi_file_close
{
	# Solo se riposizioniamo le chiamate di domopi_file_close
	#unset DOMOPI_SCHEMA_$SCHEMA
	[ -n "$1" -a $1 -ne 255 ] && eval "exec $1>&-" && _release_file_descriptor $1
}


#
#
#	$1 - file descriptor 
#	$2 - token
#
# @author Andrea Tassotti
#
#private domopi_file_read_token
function _domopi_file_read_token()
{
	[ $# -lt 2 ] && return 3
	local TOKEN
	read TOKEN VALUE <&$1
	[ $TOKEN != "$2" ] && echo ERROR: unexpected token at line 2 >&2 && return 2
	return 0
}


#
# Get column numbert (position) from conf header
#
#	Read schema directly from file is useful for
#	backward schema compatibility
#	Return index in DOMOPI_CONF_FILE_COL_NUMBER
#
#	$1 - schema name
#	$2 - Column name
#
#	return 0 on succedd
#
# 
# @author Andrea Tassotti
#
#private domopi_column_by_name
function _domopi_column_by_name()
{
	if [ $# -eq 2 ]; then
		DOMOPI_CONF_FILE_COL_NUMBER=$( eval echo \${DOMOPI_SCHEMA_COL_$1[$2]} )
		echo $DOMOPI_CONF_FILE_COL_NUMBER
		return 0
	else
		echo FATAL: missing arguments >&2
		return 255
	fi
}


#
# Get next val for SEQUENTIAL type column
#
# 
# $1 - file name
# $2 - column (name)
# $3 - min (default 0)
# $4 - max (default 1000)
#
# @author Andrea Tassotti
#
#private domopi_seq_nextval
function _domopi_seq_nextval()
{
	[ -z "$DOMOPI_SCHEMA_NAME" ] && return 1

	_domopi_column_by_name "$DOMOPI_SCHEMA_NAME" "$2" >/dev/null
	[ -z "$DOMOPI_CONF_FILE_COL_NUMBER" ] && return 2

	local ACTUAL_ID_TMP=$(mktemp)
	local FULL_ID_TMP=$(mktemp)
	
	grep -v '^#' "$1" | cut -d: -f$((DOMOPI_CONF_FILE_COL_NUMBER + 1 ))| egrep '^[0-9]+$' | sort -g | tee >$ACTUAL_ID_TMP

	local maxid=$(tail -1 $ACTUAL_ID_TMP)

	if [ ${maxid:-0} -gt ${4:-1000} ]
	then
		echo 'Sequence exceed maximum' >&2 
		# cleanup
		rm $ACTUAL_ID_TMP $FULL_ID_TMP
		return
	fi
	seq $minid $((maxid + 1)) >	$FULL_ID_TMP
	nextid=$(join -v 1 $FULL_ID_TMP $ACTUAL_ID_TMP | head -1 )
	eval DOMOPI_${2^^}_COLUMN_NEXT_ID=$nextid
	echo $nextid

# cleanup
	rm $ACTUAL_ID_TMP $FULL_ID_TMP
}


#
#
#
#
#
function _domopi_desc()
{
	file=$1
	## Read schema
	_domopi_file_open "$file"
	fd=$?
	_domopi_file_close $fd

	echo "File  : $file"
	echo "Schema: $DOMOPI_SCHEMA_NAME"
	echo "Struct:"

	local i=1
	for key in  $( eval echo \${DOMOPI_SCHEMA_$DOMOPI_SCHEMA_NAME[@]} )
	do
		echo -en "   $i\t$key"
		case "$key" in
		*ID)
			echo -e "\tKEY, AUTO_INCREMENT"
			;;
		*U)
			echo -e "\tUNIQUE"
			;;
		*)
			echo ;;
		esac
		i=$((i+1))
	done

}



#
# Domopi conf file CRUD
#
#	$1   - File di configurazione contenente la tabella
#	$2-n - Colonne da visualizzare
#	$n-m - Clausole da rispettare
#
#	x Ã¨ considerato null
#
#	-v Verbose mode (invece che tabellare) esprimei nomi delle variabili impostate
#	-d<delim> Delimitatore per output tabellare (default)
#	-q  Sopprime intestazione colonne e indicazioni numero righe
#
#	Sintassi argomenti:
#	lista di nomi colonne per la select
#	lista coppie key=value per chiavi ricerca (AND)
#	lista coppie key='null' o key='!null' per IS NULL o IS NOT NULL
#
#	Nel caso di colonne ID$ 'x' significa 'non significativo'
#
#	Restituisce in STDOUT tabella nome=valore
#	e nel contempo imposta variabili DOMOPI_nome
#
#	TODO: Attenzione. Le colonne oggetto di ricerca non vengono valorizzate
#			in uscita se non fanno parte della lista colonne. Possono
#			essere presenti dati sporchi
#
#	Esempio:
#
#	Match diretto
#	_domopi_select_row global.cfg currentstate sensorID=1
#	Consente uso espressioni regolari:
#	_domopi_select_row global.cfg currentstate descriptionU=Luce.*alta
#
function _domopi_select_row()
{
	local VERBOSE=false
	DELIMITER="\t"
	HEADER=true
	FOOTER=true

	[ -z "$DOMOPI_SCHEMA_NAME" ] && echo schema missing >&2 && return 1

	# Processa opzioni locali
	local OPTIND=1 OPTARG opt
	while getopts "d:qv" opt; do
		case $opt in
		v)	VERBOSE=true ; HEADER=false ;;
		q)	HEADER=false ; FOOTER=false ;;
		d)	DELIMITER="$OPTARG" ;;
		:)	echo argument required ; return ;;
		esac
	done
	shift $((OPTIND-1))

	file=$1
	[ ! -f "$file" ] && return 255
	shift
	declare -A where
	declare -A columns

	local position=0

	for a in "$@"
	do
		# ricerca = per creare criterio ricerca
		if [[ "$a" =~ .*=.* ]]; then
			key="${a%%=*}"
			value="${a##*=}"
			where[$key]="$value"
		else
			unset DOMOPI_$a
			columns["$a"]=$position
			position=$((position+1))
		fi
	done

	if [ ${#columns[@]} -eq 0 ] 
	then
		echo "ERROR: no select list column" >&2
		return 1
	fi

	local row_to_match=""

	for key in  $( eval echo \${DOMOPI_SCHEMA_$DOMOPI_SCHEMA_NAME[@]} )
	do
		if [ -n "${where[$key]}" ]
		then
			if [[ "${where[$key]}" = "!null" ]]; then
				row_to_match="${row_to_match}.+:"
			elif [[ "${where[$key]}" = "null" ]]; then
				row_to_match="${row_to_match}:"
			else
				row_to_match="$row_to_match${where[$key]}:"
			fi
		else
			row_to_match="${row_to_match}.*:"
		fi
	done
	# Trim : right
#	row_to_match=${row_to_match%"${row_to_match##*[!:]}"}

	local cut_fields=""
	local column_reduced=0
	declare -a columns_to_show

	for key in  $( eval echo \${DOMOPI_SCHEMA_$DOMOPI_SCHEMA_NAME[@]} )
	do
		if [ -n "${columns[$key]}" ]
		then
			_domopi_column_by_name $DOMOPI_SCHEMA_NAME $key >/dev/null
			cut_fields="${cut_fields}$((DOMOPI_CONF_FILE_COL_NUMBER+1)),"
			columns_to_show[$column_reduced]=$key
			column_reduced=$((column_reduced+1))
		fi
	done

	# rtrim ,
	cut_fields=${cut_fields%"${cut_fields##*[!,]}"}

	# Prepariamo ordinamennto output
	declare -a posizioni
	for col in ${!columns[@]}
	do
		pos=${columns[$col]}
		posizioni[$pos]=$col
	done

	local _TMP=$(mktemp)

	# 
	# NOTA: cut non riordina i campi estratti
	if [ -n "$cut_fields" ] ; then
		local i=0
		local pos row
		local colname

		local SPOOL=$(mktemp)


		if $HEADER; then
		echo
		for pos in ${!posizioni[@]}
		do
			echo -ne "${posizioni[$pos]}$DELIMITER"
		done
		echo
		echo 
		fi	> $SPOOL

		# Impossibile costrutto pipe: deve generare variabili globali
# TODO: ulteriore miglioramento rimuovendo cut eprocessando cut_fields tramite selezione su array row
#
		egrep "$row_to_match" "$file" | cut -d: -f$cut_fields > $_TMP
		while read row
		do
			IFS=: read -a row <<< "$row"
			local c=0
			c=0

			# Output ordinato
			for pos in ${!posizioni[@]}
			do
				colname=${posizioni[$pos]}	
				local index
				# Index of value
				for idx in ${!columns_to_show[@]}
				do
					[ ${columns_to_show[$idx]} == $colname ] && index=$idx && break
				done
				$VERBOSE && echo -n $colname[$i]=

				# Per columns occorre che un campo sia non vuoto
				[ -n "${row[$index]}" ] && echo -ne ${row[$index]} || echo -ne ' '
				! $VERBOSE && echo -ne "$DELIMITER"
				$VERBOSE && echo
				[ -n "$index" ] && eval DOMOPI_$colname\[$i\]=\"\$\{row[$index]\}\"
				c=$((c+1))
			done

			i=$((i+1))
			echo
		done < $_TMP >>$SPOOL

		$FOOTER && echo "$i row(s) selected." >>$SPOOL
		column -t -s $'\t' $SPOOL
	fi

	rm -f $_TMP $SPOOL

	return 0
}


#
# Domopi conf file CRUD
#
#	Inserisce una riga nel file indicato
#	rispettando il suo schema.
#	In argomento sono passate coppie chiave valore;
#	se la chiave coincide con lo schema allora viene
#	inserita (altrimenti viene silentemente ignorata).
#	Le colonne auto-increment devono esprimere un valore *;
#	sono autoincrement solo le colonne il cui nome termina con ID.
#	Sono invece univoche le colonne che terminano con U.
#	Si ricordi che i nomi di colonna sono minuscoli, quindi
#	il suffisso maiuscolo Ã¨ un tipo/caratteristica
#
#	$1 - File di configurazione contenente la tabella
#	$@ - lista coppie key:value per i valori
#
#
function _domopi_insert_row()
{
	[ -z "$DOMOPI_SCHEMA_NAME" ] && return 1

	file=$1
	[ ! -f "$file" ] && return 255
	shift

	declare -A values
	local a

	for a in "$@"
	do
		[ -z "$a" ] && continue
		key="${a%%:*}"
		value="${a##*:}"
		if [[ "$key" =~ ID$ ]] && [ "$value" = '*' ]
		then
			value=$( _domopi_seq_nextval "$file" "$key" )
		fi

		# Deve rispettare univocitÃ  delle colonne che finiscono con U
		if [[ "$key" =~ U$ ]]
		then
			_domopi_column_by_name "$DOMOPI_SCHEMA_NAME" "$key" >/dev/null
			if grep -v '^#' "$file" | cut -d: -f$((DOMOPI_CONF_FILE_COL_NUMBER + 1 ))| grep "$value" >/dev/null
			then
				echo WARNING: duplicate value $value in column $key >&2
				return 255
			fi
		fi

		values[$key]="$value"
	done

	
	local row=""
	local _TMP=$(mktemp)
	for key in  $( eval echo \${DOMOPI_SCHEMA_$DOMOPI_SCHEMA_NAME[@]} )
	do
		if [ -n "${values[$key]}" ]
		then
			value="${values[$key]}"
		else
			# NULL indicator per ID
			value=
			[[ "$key" =~ ID$ ]] && value=x
		fi
		row="$row$value:"
	done

	echo "$row" >>"$file"

	return 0
}


##
#	Rimozione di righe in file di configurazione
#
# Domopi conf file CRUD
#
#	$1 - File di configurazione contenente la tabella
#	$@ - lista coppie key=value per chiavi ricerca (AND)
#	$? - 0 = cancellazione avvenuta, 1 = cancellazione non avvenuta, 255 = errore nella gestione file
#
function _domopi_delete_row()
{
	local VERBOSE=false

	[ -z "$DOMOPI_SCHEMA_NAME" ] && return 1

	# Processa opzioni locali
	local OPTIND=1 OPTARG opt
	while getopts ":v" opt; do
		case $opt in
		v)	VERBOSE=true ;;
		:)	echo argument required ; return ;;
		esac
	done
	shift $((OPTIND-1))

	file=$1
	[ ! -f "$file" ] && return 255
	shift
	declare -A where

	for a in "$@"
	do
		[ -z "$a" ] && continue
		# ricerca = per criterio ricerca
		if [[ "$a" =~ .*=.* ]]; then
			key="${a%%=*}"
			value="${a##*=}"
			# Il criterio deve essere espresso (sicurezza)
			[ -n "$value" ] && where["$key"]=$value
		fi
	done

	# Non ci sono clausole di ricerca
	[ ${#where[@]} -eq 0 ] && return 1

	local row_to_match=""
	
	for key in  $( eval echo \${DOMOPI_SCHEMA_$DOMOPI_SCHEMA_NAME[@]} )
	do
		if [ -n "${where[$key]}" ]
		then
			row_to_match="$row_to_match${where[$key]}:"
		else
			row_to_match="${row_to_match}.*:"
		fi
	done
	# Trim : right
#	row_to_match=${row_to_match%"${row_to_match##*[!:]}"}


	local _TABLE=$(mktemp)
	local row local row_number
	local rows_deleted=0
	local ARGS=""
	grep -n "$row_to_match" "$file" >$_TABLE
	while read row
	do
		row_number=${row%%:*}
		# Accumula riga di configurazione sed
		if [ $row_number -gt 2 ]; then
			ARGS="${ARGS}-e \"${row_number}d\" "
			rows_deleted=$((rows_deleted+1))	
		fi
	done < $_TABLE

	# Solo se non match con intestazione
	if [[ $rows_deleted -gt 0 ]]; then
		eval sed -i.bak $ARGS "$file"
	fi
	$VERBOSE && echo "$rows_deleted row(s) deleted."

	rm -f $_TABLE

	[[ $rows_deleted -gt 0 ]] && return 0
	return 1
}



#
# Domopi conf file CRUD
#
#	$1 - File di configurazione contenente la tabella
#	$@ lista coppie key:value per i valori da impostare,  lista coppie key=value per chiavi ricerca (AND)
#	$? - 0 = aggiornamento avvenuto, 1 = aggiornamento non avvenuto, 255 = errore nella gestione file
#
function _domopi_update_row()
{
	local VERBOSE=false

	[ -z "$DOMOPI_SCHEMA_NAME" ] && echo 'No schema' >&2 && return 1

	# Processa opzioni locali
	local OPTIND=1 OPTARG opt
	while getopts ":v" opt; do
		case $opt in
		v)	VERBOSE=true ;;
		:)	echo argument required ; return ;;
		esac
	done
	shift $((OPTIND-1))

	file=$1
	[ ! -f "$file" ] && return 255
	shift
	declare -A where
	declare -A columns

	for a in "$@"
	do
		[ -z "$a" ] && continue

		# ricerca = per criterio ricerca
		if [[ "$a" =~ .*=.* ]]; then
			key="${a%%=*}"
			value="${a##*=}"
			where[$key]="$value"
		fi
		# ricerca : per set
		if [[ "$a" =~ .*:.* ]]; then
			key="${a%%:*}"
			value="${a##*:}"
			if ! [[ "$key" =~ ID$ ]]; then
				columns[$key]="$value"
			fi
		fi
	done

	# Non ci sono clausole di ricerca
	[ ${#where[@]} -eq 0 ] && return 1

	local row_to_match=""
	local row_as_is=""

	for key in	$( eval echo \${DOMOPI_SCHEMA_$DOMOPI_SCHEMA_NAME[@]} )
	do
		if [ -n "${where[$key]}" ]
		then
			row_to_match="$row_to_match${where[$key]}:"
		else
			row_to_match="${row_to_match}.*:"
		fi
	done
	# Trim : right
	#row_to_match=${row_to_match%"${row_to_match##*[!:]}"}

	local _TABLE=$(mktemp)
	local ARGS=""
	local row row_number row_as_is row_to_be
	local rows_updated=0
	egrep -n "$row_to_match" "$file" >$_TABLE

	while read row
	do
		row_number=${row%%:*}
		row_as_is=${row#*:}

		IFS=: read -r -a row_data <<< "$row_as_is"

		# Calcola offset compreso header
		local row_to_be=""
		for key in	$( eval echo \${DOMOPI_SCHEMA_$DOMOPI_SCHEMA_NAME[@]} )
		do
			if [ -n "${columns[$key]}" ]
			then
				row_to_be="$row_to_be${columns[$key]}:"
			else
				# Deve recuperare il vero dato
				_domopi_column_by_name "$DOMOPI_SCHEMA_NAME" "$key" >/dev/null
				dato=${row_data[$DOMOPI_CONF_FILE_COL_NUMBER]}
				row_to_be="${row_to_be}$dato:"
			fi
		done

		# Accumula riga di configurazione sed
		if [ $row_number -gt 2 ]; then
			ARGS="${ARGS}-e \"${row_number}c$row_to_be\" "
			rows_updated=$((rows_updated+1))	
		fi
	done < $_TABLE


	# Solo se non match con intestazione
	if [[ $rows_updated -gt 0 ]]; then
		eval sed -i.bak $ARGS "$file"
	fi
	$VERBOSE && echo "$rows_updated row(s) updated."

	rm -f $_TABLE

	[[ $row_updated -gt 0 ]] && return 0
	return 1
}

#
# PROPOSAL:
#
#	Directory API extensions to autoload
#


#-----------------------------------------------
# Begin-of-API
#-----------------------------------------------

# NOTA GENERALE: le funzioni (proprie) con un output
#		avranno in realtÃ  un doppio output (oltre exit code).
#		Uno a STDOUT e uno con variabile pari a DOMOPI_RESULT
#		oppure ad un nome semanticamente collegato alla funzione
#		e con prefisso DOMOPI_
#

##
#
#
public domopi_help
function domopi_help()
{
	echo "API Public functions:"
	echo
	for f in $DOMOPI_PUBLIC_FUNC_LIST
	do
		echo -e "\t$f()"
	done | sort
	echo
	echo "Use domopi_man <function_name> for details"
}

##
#	Il sommario
#
#	Descrizione lunga
#
#	@see bashdoc
#
public domopi_man
function domopi_man()
{
/usr/bin/awk '
/^##/				{ incomment=1; insummary=1; text=""; getline; }
/^#[[:blank:]]*$/	{ insummary=0; getline; }
/^#[[:blank:]]*[\-][a-zA-Z]+/ { if (incomment) { insummary=0; par=""; for(i=2;i<=NF;i++) par=par" "$i; o[$2]=par; next; } }
/^#[[:blank:]]*[\@]author/ { if (incomment) { insummary=0; author=""; for(i=3;i<=NF;i++) author=author$i" "; next; } }
/^#[[:blank:]]*[\@]note/ { if (incomment) { insummary=0; n=""; for(i=3;i<=NF;i++) n=n$i" "; note[length(note)]=n; next; } }
/^#[[:blank:]]*[\@]see/ { if (incomment) { insummary=0; s=""; for(i=3;i<=NF;i++) s=s$i" "; see[length(see)]=s; next; } }
/^#.*[\$][0-9\?]+/	{ if (incomment) { par=""; for(i=2;i<=NF;i++) par=par" "$i; h[$2]=par; next; } }
/^function /		{ if ( incomment && $2 == "'"$1()"'" ) { print "Funzione   : "$2; print "Sommario   : "summary; print "Descrizione: "text; print "Autore     : "author; for(v in note) print "Nota       : "note[v]; for(v in see) print "Vedi       : "see[v]; print "Parametri  :"; for(v in h) print h[v]; print "Opzioni    :"; for(v in o) print o[v]    ; print ""; } incomment=0; insummary=0; delete h; delete o; delete note; delete see; text=""; next; }
					{ if ( incomment ) { if ( insummary ) { text=""; summary=""; for(i=2;i<=NF;i++) summary=summary$i" "; } else { if (NF>2){ for(i=2;i<=NF;i++) text=text$i" "; text=text"\n\t"; } } } } ' $DOMOPI_API_PATH
}


##
#	Avvia timer per tracciamento durata operazione
#
#	$1 - (opzionale) Nome del timer
#
#	@author	Andrea Tassotti
#
function domopi_timer_start()
{
	declare -g DOMOPI_OP_START_TIME_$1
	eval DOMOPI_OP_START_TIME_$1=$( date '+%s%N' )
}


##
#	Mostra tempo impiegato da operazione in msec
#
#	$1 - (opzionale) Nome del timer
#
#	@author	Andrea Tassotti
#
function domopi_time_elapsed()
{
	PROMPT=
	[[ "$1" = '-q' ]] && PROMPT=-q && shift
	DOMOPI_OP_END_TIME=$( date '+%s%N' )
	eval START=\$DOMOPI_OP_START_TIME_$1
	[ -z "$DOMOPI_OP_START_TIME_$1" ] && return 1
	time=$( echo "( $DOMOPI_OP_END_TIME - $START ) / 1000000" | bc )
	domopi_notice $PROMPT "Operazione '${1:-anonymous}' conclusa in $time msec"
}


##
#
#
#
function domopi_notice()
{
	PROMPT=true
	[[ "$1" = '-q' ]] && PROMPT=false && shift
	echo
	echo $@
	if $PROMPT; then
		echo 'Premi invio per proseguire'
		read
	fi
}


##
#	getIdentity
#
#	$1 - filter component (ident, uuid, created)
#
#	$? - file descriptor or 255 on error
#
#	@author Andrea Tassotti
#
function domopi_ident()
{
	_domopi_file_open $DOMOPI_IDENT_FILE
	fd=$?

	if [ $fd -ne 255 ]
	then
		_domopi_file_read_token $fd 'ident:' && DOMOPI_IDENT_IDENT=$VALUE &&
		_domopi_file_read_token $fd 'uuid:' && DOMOPI_IDENT_UUID=$VALUE &&
		_domopi_file_read_token $fd 'created:' && DOMOPI_IDENT_CREATED=$VALUE &&
		# global/external command use
		echo $DOMOPI_IDENT_IDENT $DOMOPI_IDENT_UUID $DOMOPI_IDENT_CREATED
		_domopi_file_close $fd
	fi
	
	return 1
}




##
#	Crea identitÃ  e file di configurazioni
#
#	Da utilizzare una sola volta nel ciclo di vita del
#	sistema per creare i file di configurazione richiesti.
#
#	$1 -	Identity	
#
#	@note ATTENZIONE! Operazione irreversibile
#	@author Andrea Tassotti
#
public domopi_init
function domopi_init()
{
	if [ -z "$1" ]
	then
		echo "ERROR: identity missing." >&2
		return 1
	fi

	if [ ! -f "$DOMOPI_CONF_TEMPLATE_PATH/$DOMOPI_MODULES_CONF" ]; then
		echo "ERROR: hardware configuration missing." >&2
		return 2
	fi

	# Rimuove vecchie configurazioni
	rm -f "$DOMOPI_EXTENDED_CONF_PATH/${DOMOPI_MODULES_CONF%%.$DOMOPI_CONF_EXTENTION}-"*.$DOMOPI_CONF_EXTENTION

	# Generate Identity file

	# generate uuid
	if [ -x /usr/bin/uuidgen ]; then
		UUID=$(/usr/bin/uuidgen)
	else # less accurate uuid
		UUID=$(printf %04x%04x-%04x-%04x-%04x-%04x%04x%04x $RANDOM $RANDOM $RANDOM $RANDOM $RANDOM $RANDOM $RANDOM $RANDOM )
	fi
	echo "$DOMOPI_FILE_FINGERPRINT" '$ident$' >$DOMOPI_IDENT_FILE
	echo "ident: $1" >>$DOMOPI_IDENT_FILE
	echo "uuid: $UUID" >>$DOMOPI_IDENT_FILE
	echo "created: $(date +%s)" >>$DOMOPI_IDENT_FILE

	# Generate global configuration file (empty with schema)
	echo "$DOMOPI_FILE_FINGERPRINT" '$global$' >$DOMOPI_GLOBAL_CONF
	echo "${DOMOPI_FILE_SCHEMA['global']}" >>$DOMOPI_GLOBAL_CONF

	# Install exportable version
	cp "$DOMOPI_CONF_TEMPLATE_PATH/$DOMOPI_MODULES_CONF" "$DOMOPI_EXTENDED_CONF_PATH/${DOMOPI_MODULES_CONF%%.$DOMOPI_CONF_EXTENTION}-$UUID.$DOMOPI_CONF_EXTENTION"

	# Reboot API
	[ -f $DOMOPI_IDENT_FILE ] && domopi_ident 
	return 0
}


##
#
#	Genera file di struttura hardware
#
#	@author Andrea Tassotti
#
public domopi_install
function domopi_install
{
	if [ ! -f "$DOMOPI_CONF_TEMPLATE_PATH/$DOMOPI_MODULES_CONF" ]; then
		# Generate global configuration file (empty with schema)
		echo "$DOMOPI_FILE_FINGERPRINT" '$modules$' >$DOMOPI_CONF_TEMPLATE_PATH/$DOMOPI_MODULES_CONF
		echo "${DOMOPI_FILE_SCHEMA['modules']}" >>$DOMOPI_CONF_TEMPLATE_PATH/$DOMOPI_MODULES_CONF
	else
		echo "ERROR: hardware configuration exists." >&2
		return 2
	fi
}



##
#	Creazione configurazione oggetti di base
#
#	Ancora incompleto.
#	Scrive nel file determinato dalla variabile
#	ambientale DOMOPI_GLOBAL_CONF creato con domopi_init
#
#	$1 - 'sensor', 'group'
#	$2 - name
#
#	-d device UUID
#	-g groupid TODO
#	-p <patchNumber>
#	-t <type>	TODO: letto dal file di struttura
#	-w <wiredPI>	TODO: letto dal file di struttura
#
#	@author Andrea Tassotti
#
public domopi_create
function domopi_create()
{
	local VERBOSE=false
	local PATCH
	local PATCHNUMBER
	local ret
	local device
	local DEFAULTSTATE
	local WIREDPI
	local TYPE=group
	local MODULES_CONF_FILE
	local IS_VIRTUAL=false
	local UUID=$DOMOPI_IDENT_UUID	# local device

	# Processa opzioni locali
	local OPTIND=1 OPTARG opt
	while getopts ":d:g:p:t:vw:" opt; do
		case $opt in
		d)	UUID=$OPTARG ;;	# remote device
		g)	GROUPID=$OPTARG ;;	# solo per sensori
		p)	PATCHNUMBER=$OPTARG ;;
		t)	TYPE=$OPTARG ;;
		v)	VERBOSE=true ;;
		w)	WIREDPI=$OPTARG ;;
		:)	echo argument required ; return ;;
		esac
	done
	shift $((OPTIND-1))

	MODULES_CONF_FILE="$DOMOPI_EXTENDED_CONF_PATH/${DOMOPI_MODULES_CONF%%.$DOMOPI_CONF_EXTENTION}-${UUID}.$DOMOPI_CONF_EXTENTION" 

	if [ ! -f "$MODULES_CONF_FILE" ]; then
		echo "ERROR: hardware running configuration missing." >&2
		return 2
	fi
	echo "NOTICE: selected $MODULES_CONF_FILE" >&2

	PATCH=""
	case "$TYPE" in
	"LIGHT")
		[ -n "$PATCHNUMBER" ] && PATCH="patchout:$PATCHNUMBER" 
		;;
	"NOLIGHT")
		[ -n "$PATCHNUMBER" ] && PATCH="patchout:$PATCHNUMBER" 
		;;
	"SWITCH")
		[ -n "$PATCHNUMBER" ] && PATCH="patchin:$PATCHNUMBER" 
		;;
	"VSWITCH")
		[ -n "$PATCHNUMBER" ] && PATCH="patchin:$PATCHNUMBER" 
		IS_VIRTUAL=true
		DEFAULTSTATE=0
		;;
	"ALARM")
		[ -n "$PATCHNUMBER" ] && PATCH="patchout:$PATCHNUMBER patchin:$PATCHNUMBER" 
		;;
	"OTHER")
		;;
	"PULSE")
		[ -n "$PATCHNUMBER" ] && PATCH="patchin:$PATCHNUMBER" 
		;;
	"GSWITCH")
		IS_VIRTUAL=true
		DEFAULTSTATE=0
		if [ -n "$PATCHNUMBER" ] || [ -n "$WIREPI" ]; then
			echo 'ERROR: group switch *must* not have patch and wiredpi number' >&2 
			return 1
		fi
		if [ -z "$GROUPID" ]; then
			echo 'ERROR: group switch *must* have groupid. Use -g' >&2 
			return 1
		fi
		;;
	*)
		echo FATAL: type $TYPE not implemented >&2
		return 1
		;;
	esac


	case "$1" in
	sensor)
		# Ricerca wiredpi per tipo tra disponibili

		## un virtual switch non wiredpi
		if ! $IS_VIRTUAL ; then

			# Read schema
			_domopi_file_open $MODULES_CONF_FILE
			fd=$?	# Non usato direttamente
			[ $fd -eq 255 ] && return 1
			#$DOMOPI_SCHEMA_NAME

			if [ -z "$WIREDPI" ]; then
				_domopi_select_row -q "$MODULES_CONF_FILE" defaultstate wiredpi type=$TYPE used=false >/dev/null
				# Legge solo la prima risposta
				read DEFAULTSTATE REST <<< "${DOMOPI_defaultstate[@]}"
				read WIREDPI REST <<< "${DOMOPI_wiredpi[@]}"
				if [ -z "$WIREDPI" ] && [ "$TYPE" != "VSWITCH" ]
				then
					echo "ERROR: no more wiredpi available on device $UUID" >&2
					_domopi_file_close $fd
					return 1
				fi

				_domopi_update_row "$MODULES_CONF_FILE" used:true wiredpi=$WIREDPI
			else
				_domopi_select_row -q "$MODULES_CONF_FILE" used wiredpi="$WIREDPI" >/dev/null
				if [[ "${DOMOPI_used[@]}" = "true" ]] 
				then
					echo "ERROR: wiredpi $WIREDPI is used by a sensor on device $UUID" >&2
					_domopi_file_close $fd
					return 1
				fi
				[ -z "${DOMOPI_used[@]}" ] &&
					echo "ERROR: wiredpi $WIREDPI have no connection on device $UUID. May be not work properly" >&2

			fi

			_domopi_file_close $fd
		fi

		# Read configuration schema
		_domopi_file_open "$DOMOPI_GLOBAL_CONF"
		fd=$?	# Non usato direttamente
		[ $fd -eq 255 ] && return 1

		# Verifica gruppo (se espresso)
		if [ -n "$GROUPID" ]; then
			_domopi_select_row -q "$DOMOPI_GLOBAL_CONF" groupID "groupID=$GROUPID" >/dev/null
			[ ${#DOMOPI_groupID[@]} -eq 0 ] && echo ERROR: domopi_create: group $GROUPID does not exists. >&2 && return 3
		fi


		# TODO: device potrÃ  essere un ID sequenziale in presenza
		#		di master.cfg che definisca il legame con UUID
		echo "NOTICE: master.cfg ignored: device use UUID" >&2
		_domopi_insert_row "$DOMOPI_GLOBAL_CONF" device:"$UUID" sensorID:'*' "descriptionU:$2" currentstate:"$DEFAULTSTATE" wiredpi:"$WIREDPI" type:"$TYPE" groups:"$GROUPID" "$PATCH" 

		# NOTA: Il vincolo di univocitÃ  sulle descrizioni impone
		#		di alterare il nome originale.
		#	TODO: Per il momento applichiamo suffisso VIRT
		#
		#$AUTO_CREATE_VIRTUAL && [ "$TYPE" = "SWITCH" ] &&
		#_domopi_insert_row "$DOMOPI_GLOBAL_CONF" device:"$UUID" sensorID:'*' "descriptionU:${2}VIRT" currentstate:"$DEFAULTSTATE" type:"VSWITCH" "$PATCH" 
		#ret=$?

		_domopi_file_close $fd
		;;
	group)
		# Read schema
		_domopi_file_open "$DOMOPI_GLOBAL_CONF"
		fd=$?	# Non usato direttamente
		[ $fd -eq 255 ] && return 1

		_domopi_insert_row "$DOMOPI_GLOBAL_CONF" groupID:'*' "descriptionU:$2"
		ret=$?

		_domopi_file_close $fd
		;;
	*)
		echo FATAL: $1 not implemented >&2
		return 1
		;;
	esac


	return $ret
}


##
#	Modifica attributi secondari per un sensore/gruppo
#
#	-d<UUID> Device
#	-g<ID>	Seleziona gruppo da modificare
#	-s<ID>	Selettore da modificare
#	-w<ID>	WiredPI da modificare
#	I selettori sono mutialmente esclusivi
#
#	$1 - Nome attributo
#	$2 - Nuovo valore
#
#	Attributi modificabili:
#	- patch
#	- maxExecutionTime
#	- description
#
#	@author Andrea Tassotti
#
public domopi_modify
function domopi_modify()
{
	local COLUMN_TO_MATCH=descriptionU
	local GROUP=false
	local UUID=$DOMOPI_IDENT_UUID	# local device
	local ret=1

	# Il file di configurazione deve esistere inizializzato
	# Read schema
	_domopi_file_open "$DOMOPI_GLOBAL_CONF"
	fd=$?	# Non usato direttamente
	[ $fd -eq 255 ] && return 1

	# Processa opzioni locali
	local OPTIND=1 OPTARG opt
	while getopts ":d:g:s:w:" opt; do
		case $opt in
		d)	UUID=$OPTARG ;;	# remote device
		g)	COLUMN_TO_MATCH="groups=[0-9\ ]*$OPTARG[0-9\ ]*";;
		s)	COLUMN_TO_MATCH="sensorID=$OPTARG";;
		w)	COLUMN_TO_MATCH="wiredpi=$OPTARG";;
		:)	echo argument required ; return ;;
		esac
	done
	shift $((OPTIND-1))


	_domopi_select_row -q "$DOMOPI_GLOBAL_CONF" descriptionU sensorID wiredpi type "$COLUMN_TO_MATCH" device="$UUID" >/dev/null

	for row in ${!DOMOPI_type[@]}
	do
		#echo ${DOMOPI_sensorID[$row]} ${DOMOPI_wiredpi[$row]} ${DOMOPI_descriptionU[$row]} ${DOMOPI_type[$row]}

		PATCH=""
		case "${DOMOPI_type[$row]}" in
		"LIGHT")
			[ -n "$2" ] && PATCH="patchout:$2" 
			;;
		"NOLIGHT")
			[ -n "$2" ] && PATCH="patchout:$2" 
			;;
		"SWITCH")
			[ -n "$2" ] && PATCH="patchin:$2" 
			;;
		"ALARM")
			[ -n "$2" ] && PATCH="patchout:$2 patchin:$2" 
			;;
		"OTHER")
			;;
		"PULSE")
			[ -n "$2" ] && PATCH="patchin:$2" 
			;;
		*)
			;;
		esac
	
		# TODO: device potrÃ  essere un ID sequenziale in presenza
		#		di master.cfg che definisca il legame con UUID
		echo "NOTICE: master.cfg ignored: device use UUID" >&2

		case "$1" in
		patch)
			_domopi_update_row "$DOMOPI_GLOBAL_CONF" "$PATCH" "$COLUMN_TO_MATCH" device="$UUID"
			;;
		max[eE]xecution[tT]ime)
			echo _domopi_update_row "$DOMOPI_GLOBAL_CONF" "maxExecutionTime:$2" "$COLUMN_TO_MATCH" device="$UUID"
			_domopi_update_row "$DOMOPI_GLOBAL_CONF" "maxExecutionTime:$2" "$COLUMN_TO_MATCH" device="$UUID"
			;;
		description)
			_domopi_update_row "$DOMOPI_GLOBAL_CONF" "descriptionU:$2" "$COLUMN_TO_MATCH" device="$UUID"
			;;
		esac
	done

	_domopi_file_close $fd
	return 0
}


##
#	Identifica il patch number per un sensore o gruppo
#
#	-d device UUID
#	-g<ID>	Seleziona gruppo da modificare
#	-s<ID>	Selettore da modificare
#	-w<ID>	WiredPI da modificare
#	I selettori sono mutialmente esclusivi
#
#	@author Andrea Tassotti
#
public domopi_get_patch
function domopi_get_patch()
{
	local COLUMN_TO_MATCH=descriptionU
	local UUID=$DOMOPI_IDENT_UUID	# local device
	local ret=1
	# Il file di configurazione deve esistere inizializzato
	# Read schema
	_domopi_file_open "$DOMOPI_GLOBAL_CONF"
	fd=$?	# Non usato direttamente
	[ $fd -eq 255 ] && return 1

	# Processa opzioni locali
	local OPTIND=1 OPTARG opt
	while getopts ":d:g:s:w:" opt; do
		case $opt in
		d)	UUID=$OPTARG ;;	# remote device
		g)	COLUMN_TO_MATCH="groups=[0-9\ ]*$OPTARG[0-9\ ]*";;
		s)	COLUMN_TO_MATCH="sensorID=$OPTARG";;
		w)	COLUMN_TO_MATCH="wiredpi=$OPTARG";;
		:)	echo argument required ; return ;;
		esac
	done
	shift $((OPTIND-1))

	_domopi_select_row -q "$DOMOPI_GLOBAL_CONF" type patchin patchout "$COLUMN_TO_MATCH" device="$UUID" >/dev/null

	for row in ${!DOMOPI_type[@]}
	do
		#echo ${DOMOPI_sensorID[$row]} ${DOMOPI_wiredpi[$row]} ${DOMOPI_descriptionU[$row]} ${DOMOPI_type[$row]}

		PATCH=""
		case "${DOMOPI_type[$row]}" in
		"LIGHT")
			echo ${DOMOPI_patchout[$row]}
			;;
		"NOLIGHT")
			echo ${DOMOPI_patchout[$row]}
			;;
		"SWITCH")
			echo ${DOMOPI_patchin[$row]}
			;;
		"ALARM")
			echo ${DOMOPI_patchout[$row]} ${DOMOPI_patchin[$row]}
			;;
		"OTHER")
			;;
		"PULSE")
			echo ${DOMOPI_patchin[$row]}
			;;
		*)
			;;
		esac
	done

	_domopi_file_close $fd
	return 0
}


##
#	Distruzione di un oggetto di configurazione
#
#	Il criterio di ricerca Ã¨ una espressione regolare
#	sulla descrizione dell'oggetto. Utilizzare -n
#	per utilizzare un criterio basato su ID numerico.
#
#	$1 - Tipo oggetto
#	$2 - Criterio di ricerca
#	-n - Criterio di ricerca numerico
#	-d<UUID> Device
#
#	@author Andrea Tassotti
#
public domopi_destroy
function domopi_destroy()
{
	local VERBOSE=false
	local NUMERIC=false
	local UUID=$DOMOPI_IDENT_UUID	# local device
	# Il file di configurazione deve esistere inizializzato

	# rocessa opzioni locali
	local OPTIND=1 OPTARG opt
	while getopts ":d:vn" opt; do
		case $opt in
		d)	UUID=$OPTARG ;;	# remote device
		v)	VERBOSE=true ;;
		n)	NUMERIC=true ;;
		:)	echo argument required ; return ;;
		esac
	done
	shift $((OPTIND-1))

	MODULES_CONF_FILE="$DOMOPI_EXTENDED_CONF_PATH/${DOMOPI_MODULES_CONF%%.$DOMOPI_CONF_EXTENTION}-${UUID}.$DOMOPI_CONF_EXTENTION" 
	if [ ! -f "$MODULES_CONF_FILE" ]; then
echo $MODULES_CONF_FILE
		echo "ERROR: hardware running configuration missing." >&2
		return 2
	fi
	echo "NOTICE: selected $MODULES_CONF_FILE" >&2

	case "$1" in
	sensor)
		# Read schema conf
		_domopi_file_open "$DOMOPI_GLOBAL_CONF"
		fd=$?	# Non usato direttamente
		[ $fd -eq 255 ] && return 1

		# TODO: device potrÃ  essere un ID sequenziale in presenza
		#		di master.cfg che definisca il legame con UUID
		echo "NOTICE: master.cfg ignored: device use UUID" >&2

		if $NUMERIC ; then
			_domopi_select_row -q $DOMOPI_GLOBAL_CONF wiredpi device="$UUID" sensorID="$2" >/dev/null
			_domopi_delete_row $DOMOPI_GLOBAL_CONF device="$UUID" sensorID="$2"
			ret=$?
		else
			_domopi_select_row -q $DOMOPI_GLOBAL_CONF wiredpi device="$UUID" descriptionU="$2" >/dev/null
			_domopi_delete_row $DOMOPI_GLOBAL_CONF device="$UUID" descriptionU="$2"
			ret=$?
		fi
		_domopi_file_close $fd

		# Read schema modules
		_domopi_file_open $MODULES_CONF_FILE
		fd=$?	# Non usato direttamente
		[ $fd -eq 255 ] && return 1

		local wirepi

		read wiredpi REST <<< ${DOMOPI_wiredpi[@]}

		_domopi_update_row $MODULES_CONF_FILE used:false wiredpi="$wiredpi"

		_domopi_file_close $fd

		if [ $ret -eq 0 ]; then
			echo "Oggetto cancellato correttamente"
		else
			echo "Nessun oggetto cancellabile"
		fi
		;;
	group)
		# Read schema
		_domopi_file_open "$DOMOPI_GLOBAL_CONF"
		fd=$?	# Non usato direttamente
		[ $fd -eq 255 ] && return 1
		# Determinare ID del gruppo se fornito descrittore
		# Cercare sensori appartenenti al gruppo
		 _domopi_select_row $DOMOPI_GLOBAL_CONF sensorID "groups=[0-9\ ]*$GROUPID[0-9\ ]*" 
		echo sensors ${DOMOPI_sensorID[@]}
		if $NUMERIC ; then
			echo _domopi_delete_row $DOMOPI_GLOBAL_CONF groupID="$2"
			ret=$?
		else
			echo _domopi_delete_row $DOMOPI_GLOBAL_CONF sensorID="x" descriptionU="$2"
			ret=$?
		fi
		if [ $ret -eq 0 ]; then
			echo "Oggetto cancellato correttamente"
		else
			echo "Nessun oggetto cancellabile"
		fi
		_domopi_file_close $fd
		;;
	*)
		echo FATAL: not implemented >&2
		return 1
		;;
	esac

	return 0
}



#
#	Esegue una transizione di stato utilizzando un nome di colonna
#	variabile percercare gli oggetti da modificare
#
#	$1 - columnName for match
#	$2 - value to match
#	$3 - New state [0 = low, 1 = high]
#
#	La transizionepuÃ² avvenire senza restrizioni di device
#
#
#	Utilizza DOMOPI_PRE_TRANSITION_CALLBACK per eseguire un codice
#	prima di salvare la configurazione di stato: fornire nome di una
#	funzione definita
#	Utilizza DOMOPI_POST_TRANSITION_CALLBACK per eseguire un codice
#	prima di salvare la configurazione di stato: fornire nome di una
#	funzione definita
#	In entrambi i casi viene passato il valore del nuovo stato; sono
#	disponibili le colonne della configurazione sensorID e wiredpi con:
#	${DOMOPI_device[@]}		# Consente la trasmissione puntuale
#	${DOMOPI_sensorID[@]}
#	${DOMOPI_wiredpi[@]}
#	
#
# TODO: Supportare gruppi 
#
#	@author Andrea Tassotti
#
function _domopi_do_transition_by()
{
	local UUID=$DOMOPI_IDENT_UUID	# local device
	_domopi_select_row -q "$DOMOPI_GLOBAL_CONF" device currentstate patchin $1=$2 >/dev/null
	read device REST <<< ${DOMOPI_device[@]}


	# No transition
	[[ $3 = ${DOMOPI_currentstate[0]} ]] && return 1

	# No propagation
	[ -z "${DOMOPI_patchin[0]}" ] && return 0

	# Propagation
	_domopi_select_row -q "$DOMOPI_GLOBAL_CONF" device sensorID wiredpi patchout=${DOMOPI_patchin[0]} > /dev/null
	[ "$device" != "$UUID" ] && echo "NOTICE: Propagate state on different devices" >&2

	${DOMOPI_PRE_TRANSITION_CALLBACK:-true} $3 

	in=${DOMOPI_sensorID[@]}
	in=${in/\ /\|}
	_domopi_update_row -v "$DOMOPI_GLOBAL_CONF" currentstate:$3 sensorID=$in
	${DOMOPI_POST_TRANSITION_CALLBACK:-true} $3

	return 0
}


##
#	Imposta stato di un sensore o un gruppo di sensori
#
#	$1 - Criterio di ricerca
#	$2 - New state [0 = low, 1 = high]
#	-d device UUID
#	-g - Il criterio di ricerca si riferisce ad un gruppo
#	-n - Usa criterio di ricerca numerico (ID) invece che espressione regolare su descrizione
#	-w - Usa un criterio di ricerca numerico su wiredPI
#
#	Non forza uso di alcun tipo (puo' essere numerico o alfanumerico)
#	Un valore vuoto per lo stato non cancella lo stato corrente: se
#	il sensore appartiene ad un gruppo eredita lo stato dal gruppo
#	(il primo se appartiene a piÃ¹ gruppi)
#	Aggiorna gli stati di tutti i sensori con patchout pari al patchin
#	del sensore su cui Ã¨ applicato
#
#	Utilizza DOMOPI_PRE_TRANSITION_CALLBACK per eseguire un codice
#	prima di salvare la configurazione di stato: fornire nome di una
#	funzione definita
#	Utilizza DOMOPI_POST_TRANSITION_CALLBACK per eseguire un codice
#	prima di salvare la configurazione di stato: fornire nome di una
#	funzione definita
#	In entrambi i casi viene passato il valore del nuovo stato; sono
#	disponibili le colonne della configurazione sensorID e wiredpi con:
#	${DOMOPI_sensorID[@]}
#	${DOMOPI_wiredpi[@]}
#
#
#	TODO: Implementare selettore per gruppo
#
#	Esempio: domopi_set_state 1 1
#	Esempio: domopi_set_state 1 0
#
#
#	@author Andrea Tassotti
#
public domopi_set_state
function domopi_set_state()
{
	local COLUMN_TO_MATCH=descriptionU
	local UUID=$DOMOPI_IDENT_UUID	# local device
	local GROUP=false
	local ret=1
	# Il file di configurazione deve esistere inizializzato
	# Read schema
	_domopi_file_open "$DOMOPI_GLOBAL_CONF"
	fd=$?	# Non usato direttamente
	[ $fd -eq 255 ] && return 1

	# Processa opzioni locali
	local OPTIND=1 OPTARG opt
	while getopts ":gnw" opt; do
		case $opt in
		d)	UUID=$OPTARG ;;	# remote device
		g)	GROUP=true ;;
		n)	COLUMN_TO_MATCH=sensorID ;;
		w)	COLUMN_TO_MATCH=wiredpi ;;
		:)	echo argument required ; return ;;
		esac
	done
	shift $((OPTIND-1))

	if [[ "$2" != '0' ]] && [[ "$2" != '1' ]] ; then
		echo FATAL: GPIO interface only accept 0/1 values >&2
		return 1
	fi
	

	if $GROUP ; then
		echo Gruppi non implementati
			#_domopi_update_row "$DOMOPI_GLOBAL_CONF" currentstate:$2 groupID=$1
			#_domopi_update_row "$DOMOPI_GLOBAL_CONF" currentstate:$2 sensorID=x descriptionU="$1"
		# TODO: cercare tutti i sensori che appartengono al gruppo
		#       e impostarelo stesso stato
	else
# TODO: se $2 Ã¨ vuoto, occorre cercare stato del groupID primario per il
# sensore
		_domopi_do_transition_by $COLUMN_TO_MATCH "$1" "$2"
		ret=$?
		[ $ret -eq 0 ] && _domopi_update_row "$DOMOPI_GLOBAL_CONF" currentstate:$2 $COLUMN_TO_MATCH="$1" device="$UUID"
	fi

	_domopi_file_close $fd
	return $ret
}



##
#	Legge stato di un sensore o gruppo
#
#	$1 - Criterio di ricerca
#	-d device UUID
#	-g - Il criterio di ricerca si riferisce ad un gruppo
#	-n - Usa criterio di ricerca numerico (ID) invece che espressione regolare su descrizione
#	-w - Usa un criterio di ricerca numerico su wiredPI
#
#	Restituisce lo stato in STDOUT (potendo essere anche alfanumerico)
#	Distribuito anche come ${DOMOPI_currentstate[0]}
#	Possibile avere elenco stati piÃ¹ oggetti secriterio non selettivo
#	Non forza uso di alcun tipo (ouo' essere numerico o alfanumerico)
#
#
#	Esempio: domopi_get_state -n 1
#
#
#	TODO: Implementare selettore per modulo e gruppo
#
#	@author Andrea Tassotti
#
public domopi_get_state
function domopi_get_state()
{
	local COLUMN_TO_MATCH=descriptionU
	local UUID=$DOMOPI_IDENT_UUID	# local device
	local GROUP=false
	# Il file di configurazione deve esistere inizializzato
	# Read schema
	_domopi_file_open "$DOMOPI_GLOBAL_CONF"
	fd=$?	# Non usato direttamente
	[ $fd -eq 255 ] && return 1

	# Processa opzioni locali
	local OPTIND=1 OPTARG opt
	while getopts ":gnw" opt; do
		case $opt in
		d)	UUID=$OPTARG ;;	# remote device
		g)	GROUP=true ;;
		n)	COLUMN_TO_MATCH=sensorID ;;
		w)	COLUMN_TO_MATCH=wiredpi ;;
		:)	echo argument required ; return ;;
		esac
	done
	shift $((OPTIND-1))

	if $GROUP ; then
		echo gruppi non implementati
	#		_domopi_select_row -q "$DOMOPI_GLOBAL_CONF" currentstate groupID=$1
	#		_domopi_select_row -q "$DOMOPI_GLOBAL_CONF" currentstate sensorID=x descriptionU="$1"
	else
			_domopi_select_row -q "$DOMOPI_GLOBAL_CONF" currentstate $COLUMN_TO_MATCH="$1" device="$UUID"
	fi

	_domopi_file_close $fd
	return 0
}


##
#	Legge il tipo di un sensore
#
#	$1 - Criterio di ricerca
#	-d device UUID
#	-n - Usa criterio di ricerca numerico (ID) invece che espressione regolare su descrizione
#	-w - Usa un criterio di ricerca numerico su wiredPI
#
#	Restituisce il tipo in STDOUT 
#	Distribuito anche come ${DOMOPI_type[0]}
#
#	NOTA: Non esiste funzione set in quanto il tipo Ã¨ parte 
#	della definizione di un oggetto
#
#	Esempio: domopi_get_state -n 1 
#
#	@author Andrea Tassotti
#
public domopi_get_type
function domopi_get_type()
{
	local COLUMN_TO_MATCH=descriptionU
	local UUID=$DOMOPI_IDENT_UUID	# local device
	# Il file di configurazione deve esistere inizializzato
	# Read schema
	_domopi_file_open "$DOMOPI_GLOBAL_CONF"
	fd=$?	# Non usato direttamente
	[ $fd -eq 255 ] && return 1

	# Processa opzioni locali
	local OPTIND=1 OPTARG opt
	while getopts ":gnw" opt; do
		case $opt in
		d)	UUID=$OPTARG ;;	# remote device
		n)	COLUMN_TO_MATCH=sensorID ;;
		w)	COLUMN_TO_MATCH=wiredpi ;;
		:)	echo argument required ; return ;;
		esac
	done
	shift $((OPTIND-1))

	_domopi_select_row -q "$DOMOPI_GLOBAL_CONF" type $COLUMN_TO_MATCH="$1" device="$UUID"

	_domopi_file_close $fd
	return 0
}


##
#	Legge la descrizione un sensore
#
#	-d device UUID
#	-s<ID> - Ricerca per sendorID
#	-w<ID> - Ricerca per wiredPI
#
#	Restituisce la descrizione in STDOUT 
#	Distribuito anche come ${DOMOPI_descriptionU[0]}
#
#
#	Esempio: domopi_get_description -n 1 
#
#	@author Andrea Tassotti
#
public domopi_get_description
function domopi_get_description()
{
	local COLUMN_TO_MATCH=descriptionU
	local UUID=$DOMOPI_IDENT_UUID	# local device
	# Il file di configurazione deve esistere inizializzato
	# Read schema
	_domopi_file_open "$DOMOPI_GLOBAL_CONF"
	fd=$?	# Non usato direttamente
	[ $fd -eq 255 ] && return 1

	# Processa opzioni locali
	local OPTIND=1 OPTARG opt
	while getopts ":g:s:w:" opt; do
		case $opt in
		d)	UUID=$OPTARG ;;	# remote device
		s)	COLUMN_TO_MATCH=sensorID; VALUE_TO_MATCH=$OPTARG ;;
		w)	COLUMN_TO_MATCH=wiredpi ; VALUE_TO_MATCH=$OPTARG ;;
		:)	echo argument required ; return ;;
		esac
	done
	shift $((OPTIND-1))

	echo _domopi_select_row -q "$DOMOPI_GLOBAL_CONF" descriptionU $COLUMN_TO_MATCH="$VALUE_TO_MATCH" device="$UUID"
	_domopi_select_row -q "$DOMOPI_GLOBAL_CONF" descriptionU $COLUMN_TO_MATCH="$VALUE_TO_MATCH" device="$UUID"

	_domopi_file_close $fd
	return 0
}

##
# Lista degli oggetti di configurazioni selezionati per tipo
#
#	$1 - Tipo (sensor, group, ...)
#
#	Indica ID, descrizione e stato
#
#	@author Andrea Tassotti
#
public domopi_list
function domopi_list()
{
	## Read schema
	_domopi_file_open "$DOMOPI_GLOBAL_CONF"
	fd=$?	# Non usato direttamente

	case "$1" in
	sensor)
		_domopi_select_row "$DOMOPI_GLOBAL_CONF" device sensorID descriptionU currentstate wiredpi patchin patchout "groupID=x"
		;;
	group)
		(
		echo -e "groupID\tdescriptionU\tsensors"
		_domopi_select_row -q "$DOMOPI_GLOBAL_CONF" groupID descriptionU sensorID=x >/dev/null
		for index in ${!DOMOPI_groupID[@]}
		do
			echo -ne "${DOMOPI_groupID[$index]}\t${DOMOPI_descriptionU[$index]}\t"
			(
			# NOTA: Le vatiabili DOMOPI_ hanno qui altro scope
			domopi_get_sensors_of_group ${DOMOPI_groupID[$index]} >/dev/null
			echo ${DOMOPI_descriptionU[@]}	|tr ' ' ','
			)
		done 
		)| column -t -s $'\t'

		;;
	*)
		echo NON IMPLEMENTATO
		;;
	esac

	_domopi_file_close $fd
}


##
#	Ricerca i wiredpi utilizzati in configurazione
#
#	Le opzioni di ricerca sono cumulabili in AND
#	
#	-d<id>	ricerca per device
#	-s<id>	ricerca per sensorID
#	-t<in/out>	ricerca per tipo
#	-v	Verbose mode
#
#
#	@author Andrea Tassotti
#
public domopi_get_wiredpi
function domopi_get_wiredpi()
{
	local VERBOSE=false
	local COLUMNS_TO_MATCH=""
	local UUID=$DOMOPI_IDENT_UUID	# local device
	local ret
	# Il file di configurazione deve esistere inizializzato
	# Read schema
	_domopi_file_open "$DOMOPI_GLOBAL_CONF"
	fd=$?	# Non usato direttamente
	[ $fd -eq 255 ] && return 1

	# Processa opzioni locali
	local OPTIND=1 OPTARG opt
	while getopts ":d:s:t:vw:" opt; do
		case $opt in
		d)	COLUMNS_TO_MATCH="${COLUMNS_TO_MATCH}device=$OPTARG " ;;
		s)	COLUMNS_TO_MATCH="${COLUMNS_TO_MATCH}sensorID=$OPTARG " ;;
		t)	case "$OPTARG" in	
			in)	 COLUMNS_TO_MATCH="${COLUMNS_TO_MATCH}patchin='!null' " ;;
			out) COLUMNS_TO_MATCH="${COLUMNS_TO_MATCH}patchout='!null' " ;;
			esac
			;;
		v)	VERBOSE=true ;;
		:)	echo argument required ; return ;;
		esac
	done
	shift $((OPTIND-1))

	
	if $VERBOSE ; then
		eval _domopi_select_row \"$DOMOPI_GLOBAL_CONF\" device wiredpi descriptionU $COLUMNS_TO_MATCH
	else
		eval _domopi_select_row -q \"$DOMOPI_GLOBAL_CONF\" device wiredpi $COLUMNS_TO_MATCH
	fi

	_domopi_file_close $fd
}


##
#	Aggiunge un sensore ad un gruppo
#
#	$1 - groupID
#	$2 - sensorID
#
#	@author Andrea Tassotti
#
public domopi_group_add_sensor
function domopi_group_add_sensor()
{
	local VERBOSE=false
	local ret
	# Il file di configurazione deve esistere inizializzato
	# Read schema
	_domopi_file_open "$DOMOPI_GLOBAL_CONF"
	fd=$?	# Non usato direttamente
	[ $fd -eq 255 ] && return 1

	# Processa opzioni locali
	local OPTIND=1 OPTARG opt
	while getopts ":v" opt; do
		case $opt in
		v)	VERBOSE=true ;;
		:)	echo Option argument required ; return 1 ;;
		esac
	done
	shift $((OPTIND-1))

	[ $# -lt 2 ] && echo Argument required && return 2
	
	_domopi_select_row -q "$DOMOPI_GLOBAL_CONF" groupID "groupID=$1" >/dev/null
	[ ${#DOMOPI_groupID[@]} -eq 0 ] && echo ERROR: domopi_group_add_sensor: group $1 does not exists. >&2 && return 3

	_domopi_select_row -q "$DOMOPI_GLOBAL_CONF" groups "sensorID=$2" >/dev/null

	# BUG: Non usare direttamente espressione ${DOMOPI_groups[@]}
	# nei doppi apici
	OLDGROUPS=${DOMOPI_groups[@]}
	if ! echo $OLDGROUPS | grep -w $1 >/dev/null ; then
		_domopi_update_row -q "$DOMOPI_GLOBAL_CONF" "groups:$OLDGROUPS $1" "sensorID=$2"
	else
		echo WARNING: domopi_group_add_sensor: sensor $2 belong to group $1 yet
	fi

	_domopi_file_close $fd
}


##
#	I gruppi a cui appartiene un sensore
#
#	$1 - Sensore
#
#	TODO: Aumentare informazioni
#	@author Andrea Tassotti
#
public domopi_get_groups
function domopi_get_groups()
{
	_domopi_select_row -q "$DOMOPI_GLOBAL_CONF" groups "sensorID=$1" >/dev/null
}


##
#	I sensori in un gruppo
#
#	$1 - sensorID
#
public domopi_get_sensors_of_group
function domopi_get_sensors_of_group()
{
	_domopi_select_row -q "$DOMOPI_GLOBAL_CONF" device sensorID descriptionU "groups=[0-9\ ]*$1[0-9\ ]*"
}


#-----------------------------------------------
# End-of-API
#-----------------------------------------------


#
# Bootstrap
#
echo DomoPI API bootstrap ...
[ -f $DOMOPI_IDENT_FILE ] && domopi_ident 


# Make private internal function
#
for f in $DOMOPI_PRIVATE_FUNC_LIST
do
	echo DEBUG. unsetting $f
	unset $f
done
unset private
unset $DOMOPI_PRIVATE_FUNC_LIST


#
# Esempi d'uso
#-----------------------------

# ./domopi.functions   # NON ESEGUE !
# . domopi.functions   # include la libreria
# 
# Sono diponibili come comandi (quindi anche come funzioni se incluso in un ulteriore script)
# le sole funzioni non dichiarate private.
# 
# Quindi possiamo scrivere:
# 
# domopi_ident
# 
# e ottenere a STDOUT l'identitÃ  (per un uso interattivoi e quindi feedback utente) 
# 
# oppure usare 
# 
# domopi_ident >/dev/null
# 
# per utilizzare solo la variabile DOMOPI_IDENT (uso interno ad uno script, senza over utilizzare costrutti per leggere stdout in variabile).
# 
# Il passaggio argomenti Ã¨ ovviamente consentito come per ogni funzione bash.
# 

