#!/bin/false
#	La prima riga impedisce di essere utilizzato come programma.
#	E' solo una libreria.
#
# DomoPI API
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation, either version 3 of the License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
#    Copyrights (C) 2016 
#
#	 @date:
#	 @version:
#	 @author: Andrea Tassotti
#

# Global variables (Development)
DOMOPI_CONF_PATH=.
DOMOPI_CONF_TEMPLATE_PATH=.
DOMOPI_BIN_PATH=.
DOMOPI_API_PATH=.
DOMOPI_PIPE_PATH=/tmp
DOMOPI_PIPE=$DOMOPI_PIPE_PATH/domopi.states
DOMOPI_POWERON_PATH=/var/run/domopi
DOMOPI_POWERON_FILE=$DOMOPI_POWERON_PATH/poweron

[ -f /usr/local/etc/default/domopi ] && . /usr/local/etc/default/domopi
[ -f /etc/default/domopi ] && . /etc/default/domopi


if [ -d "$DOMOPI_CONF_PATH/domopi.d" ]; then
	DOMOPI_EXTENDED_CONF_PATH=$DOMOPI_CONF_PATH/domopi.d/
else
	DOMOPI_EXTENDED_CONF_PATH=$DOMOPI_CONF_PATH
fi

# Requisiti
DOMOPI_REQUIRES="awk bc cut egrep grep sed tr id"

declare -A DOMOPI_FILE_SCHEMA

# Configuration files
DOMOPI_CONF_EXTENTION=cfg
DOMOPI_IDENT_FILE=$DOMOPI_CONF_PATH/ident.$DOMOPI_CONF_EXTENTION
DOMOPI_GLOBAL_CONF=$DOMOPI_CONF_PATH/global.$DOMOPI_CONF_EXTENTION
DOMOPI_MODULES_CONF=modules.$DOMOPI_CONF_EXTENTION

DOMOPI_FILE_FINGERPRINT='# Automatically generatedfile: do not modify!'

# Schemas is for generate initial configuration

# Logical configuration
DOMOPI_FILE_SCHEMA['global']='# groupID:device:sensorID:patchin:patchout:wiredpi:type:mode:maxexecutiontime:order:currentstate:descriptionU:alias:groups'
# NOTA: In caso di bash < 4.2 dichiarare a questo livello
#declare -A DOMOPI_SCHEMA_COL_global

# Physical configuration
DOMOPI_FILE_SCHEMA['modules']='# modulename:defaultstate:inverse:wiredpi:type:used'
# NOTA: In caso di bash < 4.2 dichiarare a questo livello
#declare -A DOMOPI_SCHEMA_COL_modules

unset DOMOPI_FILE_DESCRIPTORS
declare -a DOMOPI_FILE_DESCRIPTORS
# Declare standard opened
DOMOPI_FILE_DESCRIPTORS[0]=opened
DOMOPI_FILE_DESCRIPTORS[1]=opened
DOMOPI_FILE_DESCRIPTORS[2]=opened

unset DOMOPI_PUBLIC_FUNC_LIST


# Internal use only
# NOTE: Analogamente si poterbbe costruire una lista di funzioni definite public
# per avere automaticamente i "symbols" della API
function public()
{
	DOMOPI_PUBLIC_FUNC_LIST="$DOMOPI_PUBLIC_FUNC_LIST $@"
	return 0
}


#
#
# @author Andrea Tassotti
#
function trim() {
    local var="$*"
    var="${var#"${var%%[![:space:]]*}"}"   # remove leading whitespace characters
    var="${var%"${var##*[![:space:]]}"}"   # remove trailing whitespace characters
    echo -n "$var"
}


#
# @author Andrea Tassotti
#
function ltrim() {
    local var="$*"
    var="${var#"${var%%[![:space:]]*}"}"   # remove leading whitespace characters
    echo -n "$var"
}


#
# @author Andrea Tassotti
#
function rtrim() {
    local var="$*"
    var="${var%"${var##*[![:space:]]}"}"   # remove trailing whitespace characters
    echo -n "$var"
}


#
# @author Andrea Tassotti
#
function no_spaces()
{
    local var="$*"
	echo -n "${var/\ /}"
}


#
#
# @author Andrea Tassotti
#
function _get_file_descriptor()
{
	local i
	for((i=0;i<${#DOMOPI_FILE_DESCRIPTORS};i++))
	do
		if [[ ${DOMOPI_FILE_DESCRIPTORS[$i]} != 'opened' ]]
		then
			DOMOPI_FILE_DESCRIPTORS[$i]='opened'
			return $i
		fi
	done
	return 255
}


#
# $1 - file descriptor to release
#
# @author Andrea Tassotti
#
function _release_file_descriptor()
{
	DOMOPI_FILE_DESCRIPTORS[$1]='closed'
}


#
#
#	Restituisce una variabile DOMOPI_SCHEMA_<nome schema>
#	letta dal file contenente nomi colonne file
#	Restituisce anche DOMOPI_SCHEMA_NAME
#
#	$1 - File name
#	$2 - (optional)fingerprint schema extension
#
#	return file descriptor id or 255 if any error
#	
#
# @author Andrea Tassotti
#
#private domopi_file_open
function _domopi_file_open
{
	local SCHEMA
	unset DOMOPI_SCHEMA_NAME
	if [ ! -f "$1" ] ; then
		echo "FATAL: $1: No such file!" >&2
		return 255
	fi

	_get_file_descriptor
	fd=$?
	eval "exec $fd<> \"$1\""

	if [ $? -eq 0 ]; then
	# validate fingerprint
		IFS='$' read FINGERPRINT SCHEMA <&$fd
		if [ "$(rtrim $FINGERPRINT)" != "$DOMOPI_FILE_FINGERPRINT" ]
		then
			echo "FATAL: Not a DOMOPI file!" >&2
			echo $FINGERPRINT
			_domopi_file_close $fd
			return 255
		fi
		if [ -n "$2" ] && [ "$2" != "$SCHEMA" ]
		then
			echo "FATAL: Wrong DOMOPI $2 file!" >&2
			_domopi_file_close $fd
			return 255
		fi

		if [[ "$SCHEMA" != "ident" ]]; then
			IFS='#:' read -r -a DOMOPI_SCHEMA_$SCHEMA <&$fd
			if [ $? -ne 0 ]; then
				echo "FATAL: missing schema" >&2
				_domopi_file_close $fd
				return 255
			fi

			# Ribalta le informazioni in un array associativo
			unset DOMOPI_SCHEMA_COL_$SCHEMA
			declare -Ag DOMOPI_SCHEMA_COL_$SCHEMA
			local colIdx=0
			local DOMOPI_SCHEMA=$( eval echo \${DOMOPI_SCHEMA_$SCHEMA[@]} )
			for col in $DOMOPI_SCHEMA
			do
				eval "DOMOPI_SCHEMA_COL_$SCHEMA[$col]=$colIdx"
				colIdx=$((colIdx + 1))
			done

			DOMOPI_SCHEMA_NAME=$SCHEMA
		fi
	fi

	return $fd
}


#
#	$1 - file descriptor to close
#
# @author Andrea Tassotti
#
#private domopi_file_close
function _domopi_file_close
{
	# Solo se riposizioniamo le chiamate di domopi_file_close
	#unset DOMOPI_SCHEMA_$SCHEMA
	[ -n "$1" -a $1 -ne 255 ] && eval "exec $1>&-" && _release_file_descriptor $1
}


#
#
#	$1 - file descriptor 
#	$2 - token
#
# @author Andrea Tassotti
#
#private domopi_file_read_token
function _domopi_file_read_token()
{
	[ $# -lt 2 ] && return 3
	local TOKEN
	read TOKEN VALUE <&$1
	[ $TOKEN != "$2" ] && echo ERROR: unexpected token at line 2 >&2 && return 2
	return 0
}


#
# Get column numbert (position) from conf header
#
#	Read schema directly from file is useful for
#	backward schema compatibility
#	Return index in DOMOPI_CONF_FILE_COL_NUMBER
#
#	$1 - schema name
#	$2 - Column name
#
#	return 0 on succedd
#
# 
# @author Andrea Tassotti
#
#private domopi_column_by_name
function _domopi_column_by_name()
{
	if [ $# -eq 2 ]; then
		DOMOPI_CONF_FILE_COL_NUMBER=$( eval echo \${DOMOPI_SCHEMA_COL_$1[$2]} )
		echo $DOMOPI_CONF_FILE_COL_NUMBER
		return 0
	else
		echo FATAL: missing arguments >&2
		return 255
	fi
}


#
# Get next val for SEQUENTIAL type column
#
# 
# $1 - file name
# $2 - column (name)
# $3 - min (default 0)
# $4 - max (default 1000)
#
# @author Andrea Tassotti
#
#private domopi_seq_nextval
function _domopi_seq_nextval()
{
	[ -z "$DOMOPI_SCHEMA_NAME" ] && return 1

	_domopi_column_by_name "$DOMOPI_SCHEMA_NAME" "$2" >/dev/null
	[ -z "$DOMOPI_CONF_FILE_COL_NUMBER" ] && return 2

	local ACTUAL_ID_TMP=$(mktemp)
	local FULL_ID_TMP=$(mktemp)
	
	grep -v '^#' "$1" | cut -d: -f$((DOMOPI_CONF_FILE_COL_NUMBER + 1 ))| egrep '^[0-9]+$' | sort -g | tee >$ACTUAL_ID_TMP

	local maxid=$(tail -1 $ACTUAL_ID_TMP)

	if [ ${maxid:-0} -gt ${4:-1000} ]
	then
		echo 'Sequence exceed maximum' >&2 
		# cleanup
		rm $ACTUAL_ID_TMP $FULL_ID_TMP
		return
	fi
	seq $minid $((maxid + 1)) >	$FULL_ID_TMP
	nextid=$(join -v 1 $FULL_ID_TMP $ACTUAL_ID_TMP | head -1 )
	eval DOMOPI_${2^^}_COLUMN_NEXT_ID=$nextid
	echo $nextid

# cleanup
	rm $ACTUAL_ID_TMP $FULL_ID_TMP
}


#
#
#
#
#
function _domopi_desc()
{
	file=$1
	## Read schema
	_domopi_file_open "$file"
	fd=$?
	_domopi_file_close $fd

	echo "File  : $file"
	echo "Schema: $DOMOPI_SCHEMA_NAME"
	echo "Struct:"

	local i=1
	for key in  $( eval echo \${DOMOPI_SCHEMA_$DOMOPI_SCHEMA_NAME[@]} )
	do
		echo -en "   $i\t$key"
		case "$key" in
		*ID)
			echo -e "\tKEY, AUTO_INCREMENT"
			;;
		*U)
			echo -e "\tUNIQUE"
			;;
		*)
			echo ;;
		esac
		i=$((i+1))
	done

}



#
# Domopi conf file CRUD
#
#	$1   - File di configurazione contenente la tabella
#	$2-n - Colonne da visualizzare
#	$n-m - Clausole da rispettare
#
#	x Ã¨ considerato null
#
#	-v Verbose mode (invece che tabellare) esprimei nomi delle variabili impostate
#	-d<delim> Delimitatore per output tabellare (default)
#	-q  Sopprime intestazione colonne e indicazioni numero righe
#
#	Sintassi argomenti:
#	lista di nomi colonne per la select
#	lista coppie key=value per chiavi ricerca (AND)
#	lista coppie key='null' o key='!null' per IS NULL o IS NOT NULL
#
#	Nel caso di colonne ID$ 'x' significa 'non significativo'
#
#	Restituisce in STDOUT tabella nome=valore
#	e nel contempo imposta variabili DOMOPI_nome
#
#	TODO: Attenzione. Le colonne oggetto di ricerca non vengono valorizzate
#			in uscita se non fanno parte della lista colonne. Possono
#			essere presenti dati sporchi
#
#	Esempio:
#
#	Match diretto
#	_domopi_select_row global.cfg currentstate sensorID=1
#	Consente uso espressioni regolari:
#	_domopi_select_row global.cfg currentstate descriptionU=Luce.*alta
#
function _domopi_select_row()
{
	local VERBOSE=false
	DELIMITER="\t"
	HEADER=true
	FOOTER=true

	[ -z "$DOMOPI_SCHEMA_NAME" ] && echo schema missing >&2 && return 1

	# Processa opzioni locali
	local OPTIND=1 OPTARG opt
	while getopts "d:qv" opt; do
		case $opt in
		v)	VERBOSE=true ; HEADER=false ;;
		q)	HEADER=false ; FOOTER=false ;;
		d)	DELIMITER="$OPTARG" ;;
		:)	echo argument required ; return ;;
		esac
	done
	shift $((OPTIND-1))

	file=$1
	[ ! -f "$file" ] && return 255
	shift
	declare -A where
	declare -A columns

	local position=0

	for a in "$@"
	do
		# ricerca = per creare criterio ricerca
		if [[ "$a" =~ .*=.* ]]; then
			key="${a%%=*}"
			value="${a##*=}"
			[ -n "$key" ] && where[$key]="$value"
		else
			unset DOMOPI_$a
			columns["$a"]=$position
			position=$((position+1))
		fi
	done

	if [ ${#columns[@]} -eq 0 ] 
	then
		echo "ERROR: no select list column" >&2
		return 1
	fi

	local row_to_match=""
	local IN=""

	for key in  $( eval echo \${DOMOPI_SCHEMA_$DOMOPI_SCHEMA_NAME[@]} )
	do
		if [ -n "${where[$key]}" ]
		then
			if [[ "${where[$key]}" = "!null" ]]; then
				row_to_match="${row_to_match}.+:"
			elif [[ "${where[$key]}" = "null" ]]; then
				row_to_match="${row_to_match}:"
			elif [[ "${where[$key]}" =~ \| ]] ; then
				if [ -n "$IN" ] ; then
					echo WARNING: only one clause IN permitted. Ignoring >&2
				else
					IN="${where[$key]}"
					row_to_match="$row_to_match@:"
				fi
			else	
				row_to_match="$row_to_match${where[$key]}:"
			fi
		else
			row_to_match="${row_to_match}.*:"
		fi
	done

	# expand IN clause
	if [ -n "$IN" ] ; then
		local tmp_match=""
		for el in ${IN//\|/ }
		do
			[ -n "$tmp_match" ] && tmp_match="$tmp_match|"
			tmp_match="$tmp_match${row_to_match/@/$el}"
		done
		row_to_match=$tmp_match
	fi

	# Trim : right
#	row_to_match=${row_to_match%"${row_to_match##*[!:]}"}

	local cut_fields=""
	local column_reduced=0
	declare -a columns_to_show

	for key in  $( eval echo \${DOMOPI_SCHEMA_$DOMOPI_SCHEMA_NAME[@]} )
	do
		if [ -n "${columns[$key]}" ]
		then
			_domopi_column_by_name $DOMOPI_SCHEMA_NAME $key >/dev/null
			cut_fields="${cut_fields}$((DOMOPI_CONF_FILE_COL_NUMBER+1)),"
			columns_to_show[$column_reduced]=$key
			column_reduced=$((column_reduced+1))
		fi
	done

	# rtrim ,
	cut_fields=${cut_fields%"${cut_fields##*[!,]}"}

	# Prepariamo ordinamennto output
	declare -a posizioni
	for col in ${!columns[@]}
	do
		pos=${columns[$col]}
		posizioni[$pos]=$col
	done

	local _TMP=$(mktemp)

	# 
	# NOTA: cut non riordina i campi estratti
	if [ -n "$cut_fields" ] ; then
		local i=0
		local pos row
		local colname

		local SPOOL=$(mktemp)


		if $HEADER; then
		echo
		for pos in ${!posizioni[@]}
		do
			echo -ne "${posizioni[$pos]}$DELIMITER"
		done
		echo
		echo 
		fi	> $SPOOL

		# Impossibile costrutto pipe: deve generare variabili globali
# TODO: ulteriore miglioramento rimuovendo cut eprocessando cut_fields tramite selezione su array row
#
		egrep "$row_to_match" "$file" | cut -d: -f$cut_fields > $_TMP
		while read row
		do
			IFS=: read -a row <<< "$row"
			local c=0
			c=0

			# Output ordinato
			for pos in ${!posizioni[@]}
			do
				colname=${posizioni[$pos]}	
				local index
				# Index of value
				for idx in ${!columns_to_show[@]}
				do
					[ ${columns_to_show[$idx]} == $colname ] && index=$idx && break
				done
				$VERBOSE && echo -n $colname[$i]=

				# Per columns occorre che un campo sia non vuoto
				[ -n "${row[$index]}" ] && echo -ne ${row[$index]} || echo -ne ' '
				! $VERBOSE && echo -ne "$DELIMITER"
				$VERBOSE && echo
				[ -n "$index" ] && eval DOMOPI_$colname\[$i\]=\"\$\{row[$index]\}\"
				c=$((c+1))
			done

			i=$((i+1))
			echo
		done < $_TMP >>$SPOOL

		$FOOTER && echo "$i row(s) selected." >>$SPOOL
		column -t -s $'\t' $SPOOL
	fi

	rm -f $_TMP $SPOOL

	return 0
}


#
# Domopi conf file CRUD
#
#	Inserisce una riga nel file indicato
#	rispettando il suo schema.
#	In argomento sono passate coppie chiave valore;
#	se la chiave coincide con lo schema allora viene
#	inserita (altrimenti viene silentemente ignorata).
#	Le colonne auto-increment devono esprimere un valore *;
#	sono autoincrement solo le colonne il cui nome termina con ID.
#	Sono invece univoche le colonne che terminano con U.
#	Si ricordi che i nomi di colonna sono minuscoli, quindi
#	il suffisso maiuscolo Ã¨ un tipo/caratteristica
#
#	$1 - File di configurazione contenente la tabella
#	$@ - lista coppie key:value per i valori
#
#
function _domopi_insert_row()
{
	[ -z "$DOMOPI_SCHEMA_NAME" ] && return 1

	file=$1
	[ ! -f "$file" ] && return 255
	shift

	declare -A values
	local a

	for a in "$@"
	do
		[ -z "$a" ] && continue
		key="${a%%:*}"
		value="${a##*:}"
		if [[ "$key" =~ ID$ ]] && [ "$value" = '*' ]
		then
			value=$( _domopi_seq_nextval "$file" "$key" )
		fi

		# Deve rispettare univocitÃ  delle colonne che finiscono con U
		if [[ "$key" =~ U$ ]]
		then
			_domopi_column_by_name "$DOMOPI_SCHEMA_NAME" "$key" >/dev/null
			if grep -v '^#' "$file" | cut -d: -f$((DOMOPI_CONF_FILE_COL_NUMBER + 1 ))| grep -w "$value" >/dev/null
			then
				echo WARNING: duplicate value $value in column $key >&2
				return 255
			fi
		fi

		values[$key]="$value"
	done

	
	local row=""
	local _TMP=$(mktemp)
	for key in  $( eval echo \${DOMOPI_SCHEMA_$DOMOPI_SCHEMA_NAME[@]} )
	do
		if [ -n "${values[$key]}" ]
		then
			value="${values[$key]}"
		else
			# NULL indicator per ID
			value=
			[[ "$key" =~ ID$ ]] && value=x
		fi
		row="$row$value:"
	done

	echo "$row" >>"$file"

	return 0
}


##
#	Rimozione di righe in file di configurazione
#
# Domopi conf file CRUD
#
#	$1 - File di configurazione contenente la tabella
#	$@ - lista coppie key=value per chiavi ricerca (AND)
#	$? - 0 = cancellazione avvenuta, 1 = cancellazione non avvenuta, 255 = errore nella gestione file
#
function _domopi_delete_row()
{
	local VERBOSE=false

	[ -z "$DOMOPI_SCHEMA_NAME" ] && return 1

	# Processa opzioni locali
	local OPTIND=1 OPTARG opt
	while getopts ":v" opt; do
		case $opt in
		v)	VERBOSE=true ;;
		:)	echo argument required ; return ;;
		esac
	done
	shift $((OPTIND-1))

	file=$1
	[ ! -f "$file" ] && return 255
	shift
	declare -A where

	for a in "$@"
	do
		[ -z "$a" ] && continue
		# ricerca = per criterio ricerca
		if [[ "$a" =~ .*=.* ]]; then
			key="${a%%=*}"
			value="${a##*=}"
			# Il criterio deve essere espresso (sicurezza)
			[ -n "$value" ] && where["$key"]=$value
		fi
	done

	# Non ci sono clausole di ricerca
	[ ${#where[@]} -eq 0 ] && return 1

	local row_to_match=""
	local IN=""
	
	for key in  $( eval echo \${DOMOPI_SCHEMA_$DOMOPI_SCHEMA_NAME[@]} )
	do
		if [ -n "${where[$key]}" ]
		then
			if [[ "${where[$key]}" =~ \| ]] ; then
				if [ -n "$IN" ] ; then
					echo WARNING: only one clause IN permitted. Ignoring >&2
				else
					IN="${where[$key]}"
					row_to_match="$row_to_match@:"
				fi
			else	
				row_to_match="$row_to_match${where[$key]}:"
			fi
		else
			row_to_match="${row_to_match}.*:"
		fi
	done

	# expand IN clause
	if [ -n "$IN" ] ; then
		local tmp_match=""
		for el in ${IN//\|/ }
		do
			[ -n "$tmp_match" ] && tmp_match="$tmp_match|"
			tmp_match="$tmp_match${row_to_match/@/$el}"
		done
		row_to_match=$tmp_match
	fi

	# Trim : right
#	row_to_match=${row_to_match%"${row_to_match##*[!:]}"}

	local _TABLE=$(mktemp)
	local row local row_number
	local rows_deleted=0
	local ARGS=""
	egrep -n "$row_to_match" "$file" >$_TABLE
	while read row
	do
		row_number=${row%%:*}
		# Accumula riga di configurazione sed
		if [ $row_number -gt 2 ]; then
			ARGS="${ARGS}-e \"${row_number}d\" "
			rows_deleted=$((rows_deleted+1))	
		fi
	done < $_TABLE

	# Solo se non match con intestazione
	if [[ $rows_deleted -gt 0 ]]; then
		eval sed -i.bak $ARGS "$file"
	fi
	$VERBOSE && echo "$rows_deleted row(s) deleted."

	rm -f $_TABLE

	[[ $rows_deleted -gt 0 ]] && return 0
	return 1
}



#
# Domopi conf file CRUD
#
#	$1 - File di configurazione contenente la tabella
#	$@ lista coppie key:value per i valori da impostare,  lista coppie key=value per chiavi ricerca (AND)
#	$? - 0 = aggiornamento avvenuto, 1 = aggiornamento non avvenuto, 255 = errore nella gestione file
#
#	Nel calore da impostare "x" e "null" sono considerati valore nullo
#
function _domopi_update_row()
{
	local VERBOSE=false

	[ -z "$DOMOPI_SCHEMA_NAME" ] && echo 'No schema' >&2 && return 1

	# Processa opzioni locali
	local OPTIND=1 OPTARG opt
	while getopts ":v" opt; do
		case $opt in
		v)	VERBOSE=true ;;
		:)	echo argument required ; return ;;
		esac
	done
	shift $((OPTIND-1))

	file=$1
	[ ! -f "$file" ] && return 255
	shift
	declare -A where
	declare -A columns

	for a in "$@"
	do
		[ -z "$a" ] && continue

		# ricerca = per criterio ricerca
		if [[ "$a" =~ .*=.* ]]; then
			key="${a%%=*}"
			value="${a##*=}"
			where[$key]="$value"
		fi
		# ricerca : per set
		if [[ "$a" =~ .*:.* ]]; then
			key="${a%%:*}"
			value="${a##*:}"
			if ! [[ "$key" =~ ID$ ]]; then
				columns[$key]="$value"
			fi
		fi
	done

	# Non ci sono clausole di ricerca
	[ ${#where[@]} -eq 0 ] && return 1

	local row_to_match=""
	local row_as_is=""
	local IN=""

	for key in	$( eval echo \${DOMOPI_SCHEMA_$DOMOPI_SCHEMA_NAME[@]} )
	do
		if [ -n "${where[$key]}" ]
		then
			if [[ "${where[$key]}" =~ \| ]] ; then
				if [ -n "$IN" ] ; then
					echo WARNING: only one clause IN permitted. Ignoring >&2
				else
					IN="${where[$key]}"
					row_to_match="$row_to_match@:"
				fi
			else	
				row_to_match="$row_to_match${where[$key]}:"
			fi
		else
			row_to_match="${row_to_match}.*:"
		fi
	done

	# expand IN clause
	if [ -n "$IN" ] ; then
		local tmp_match=""
		for el in ${IN//\|/ }
		do
			[ -n "$tmp_match" ] && tmp_match="$tmp_match|"
			tmp_match="$tmp_match${row_to_match/@/$el}"
		done
		row_to_match=$tmp_match
	fi

	# Trim : right
	#row_to_match=${row_to_match%"${row_to_match##*[!:]}"}

	local _TABLE=$(mktemp)
	local ARGS=""
	local row row_number row_as_is row_to_be
	local rows_updated=0
	egrep -n "$row_to_match" "$file" >$_TABLE

	while read row
	do
		row_number=${row%%:*}
		row_as_is=${row#*:}

		IFS=: read -r -a row_data <<< "$row_as_is"

		# Calcola offset compreso header
		local row_to_be=""
		for key in	$( eval echo \${DOMOPI_SCHEMA_$DOMOPI_SCHEMA_NAME[@]} )
		do
			# In realtÃ  dovrebbe controllare che esista la chiave
			if [ -n "${columns[$key]}" ]
			then
				if [ "${columns[$key]}" = "x" ] ||
				   [ "${columns[$key]}" = "null" ] ; then
					row_to_be="${row_to_be}:"
				else
					row_to_be="$row_to_be${columns[$key]}:"
					
				fi
			else
				# Deve recuperare il vero dato
				_domopi_column_by_name "$DOMOPI_SCHEMA_NAME" "$key" >/dev/null
				dato=${row_data[$DOMOPI_CONF_FILE_COL_NUMBER]}
				row_to_be="${row_to_be}$dato:"
			fi
		done

		# Accumula riga di configurazione sed
		if [ $row_number -gt 2 ]; then
			ARGS="${ARGS}-e \"${row_number}c$row_to_be\" "
			rows_updated=$((rows_updated+1))	
		fi
	done < $_TABLE


	# Solo se non match con intestazione
	if [[ $rows_updated -gt 0 ]]; then
		eval sed -i.bak $ARGS "$file"
	fi
	$VERBOSE && echo "$rows_updated row(s) updated."

	rm -f $_TABLE

	[[ $row_updated -gt 0 ]] && return 0
	return 1
}




#
# PROPOSAL:
#
#	Directory API extensions to autoload
#


#-----------------------------------------------
# Begin-of-API
#-----------------------------------------------

# NOTA GENERALE: le funzioni (proprie) con un output
#		avranno in realtÃ  un doppio output (oltre exit code).
#		Uno a STDOUT e uno con variabile pari a DOMOPI_RESULT
#		oppure ad un nome semanticamente collegato alla funzione
#		e con prefisso DOMOPI_
#

##
#
#
public domopi_help
function domopi_help()
{
	echo "API Public functions:"
	echo
	for f in $DOMOPI_PUBLIC_FUNC_LIST
	do
		echo -e "\t$f()"
	done | sort
	echo
	echo "Use domopi_man <function_name> for details"
}

##
#	Il sommario
#
#	Descrizione lunga
#
#	@see bashdoc
#
public domopi_man
function domopi_man()
{
[ -f $DOMOPI_API_PATH/domopi.functions ] &&
/usr/bin/awk '
/^##/				{ incomment=1; insummary=1; text=""; getline; }
/^#[[:blank:]]*$/	{ insummary=0; getline; }
/^#[[:blank:]]*[\-][a-zA-Z]+/ { if (incomment) { insummary=0; par=""; for(i=2;i<=NF;i++) par=par" "$i; o[$2]=par; next; } }
/^#[[:blank:]]*[\@]author/ { if (incomment) { insummary=0; author=""; for(i=3;i<=NF;i++) author=author$i" "; next; } }
/^#[[:blank:]]*[\@]note/ { if (incomment) { insummary=0; n=""; for(i=3;i<=NF;i++) n=n$i" "; note[length(note)]=n; next; } }
/^#[[:blank:]]*[\@]see/ { if (incomment) { insummary=0; s=""; for(i=3;i<=NF;i++) s=s$i" "; see[length(see)]=s; next; } }
/^#.*[\$][0-9\?]+/	{ if (incomment) { par=""; for(i=2;i<=NF;i++) par=par" "$i; h[$2]=par; next; } }
/^function /		{ if ( incomment && $2 == "'"$1()"'" ) { print "Funzione   : "$2; print "Sommario   : "summary; print "Descrizione: "text; print "Autore     : "author; for(v in note) print "Nota       : "note[v]; for(v in see) print "Vedi       : "see[v]; print "Parametri  :"; for(v in h) print h[v]; print "Opzioni    :"; for(v in o) print o[v]    ; print ""; } incomment=0; insummary=0; delete h; delete o; delete note; delete see; text=""; next; }
					{ if ( incomment ) { if ( insummary ) { text=""; summary=""; for(i=2;i<=NF;i++) summary=summary$i" "; } else { if (NF>2){ for(i=2;i<=NF;i++) text=text$i" "; text=text"\n\t"; } } } } ' $DOMOPI_API_PATH/domopi.functions
}


##
#	Avvia timer per tracciamento durata operazione
#
#	$1 - (opzionale) Nome del timer
#
#	@author	Andrea Tassotti
#
function domopi_timer_start()
{
	declare -g DOMOPI_OP_START_TIME_$1
	eval DOMOPI_OP_START_TIME_$1=$( date '+%s%N' )
}


##
#	Mostra tempo impiegato da operazione in msec
#
#	$1 - (opzionale) Nome del timer
#
#	@author	Andrea Tassotti
#
function domopi_time_elapsed()
{
	PROMPT=
	[[ "$1" = '-q' ]] && PROMPT=-q && shift
	DOMOPI_OP_END_TIME=$( date '+%s%N' )
	eval START=\$DOMOPI_OP_START_TIME_$1
	[ -z "$DOMOPI_OP_START_TIME_$1" ] && return 1
	time=$( echo "( $DOMOPI_OP_END_TIME - $START ) / 1000000" | bc )
	domopi_notice $PROMPT "Operazione '${1:-anonymous}' conclusa in $time msec"
}


##
#
#
#
function domopi_notice()
{
	PROMPT=true
	[[ "$1" = '-q' ]] && PROMPT=false && shift
	echo
	echo $@
	if $PROMPT; then
		echo 'Premi invio per proseguire'
		read
	fi
}


##
#	getIdentity
#
#	$1 - filter component (ident, uuid, created)
#
#	$? - file descriptor or 255 on error
#
#	@author Andrea Tassotti
#
public domopi_ident
function domopi_ident()
{
	_domopi_file_open $DOMOPI_IDENT_FILE
	fd=$?

	if [ $fd -ne 255 ]
	then
		_domopi_file_read_token $fd 'ident:' && DOMOPI_IDENT_IDENT=$VALUE &&
		_domopi_file_read_token $fd 'uuid:' && DOMOPI_IDENT_UUID=$VALUE &&
		_domopi_file_read_token $fd 'created:' && DOMOPI_IDENT_CREATED=$VALUE &&
		# global/external command use
		echo $DOMOPI_IDENT_IDENT $DOMOPI_IDENT_UUID $DOMOPI_IDENT_CREATED
		_domopi_file_close $fd
	fi
	
	return 1
}




##
#	Crea identitÃ  e file di configurazioni
#
#	Da utilizzare una sola volta nel ciclo di vita del
#	sistema per creare i file di configurazione richiesti.
#
#	$1 -	Identity	
#
#	@note ATTENZIONE! Operazione irreversibile
#	@author Andrea Tassotti
#
public domopi_init
function domopi_init()
{
	if [ -z "$1" ]
	then
		echo "ERROR: identity missing." >&2
		return 1
	fi

	if [ ! -f "$DOMOPI_CONF_TEMPLATE_PATH/$DOMOPI_MODULES_CONF" ]; then
		echo "ERROR: hardware configuration missing." >&2
		return 2
	fi

	# Rimuove vecchie configurazioni
	rm -f "$DOMOPI_EXTENDED_CONF_PATH/${DOMOPI_MODULES_CONF%%.$DOMOPI_CONF_EXTENTION}-"*.$DOMOPI_CONF_EXTENTION

	# Generate Identity file

	# generate uuid
	if [ -x /usr/bin/uuidgen ]; then
		UUID=$(/usr/bin/uuidgen)
	else # less accurate uuid
		UUID=$(printf %04x%04x-%04x-%04x-%04x-%04x%04x%04x $RANDOM $RANDOM $RANDOM $RANDOM $RANDOM $RANDOM $RANDOM $RANDOM )
	fi
	echo "$DOMOPI_FILE_FINGERPRINT" '$ident$' >$DOMOPI_IDENT_FILE
	echo "ident: $1" >>$DOMOPI_IDENT_FILE
	echo "uuid: $UUID" >>$DOMOPI_IDENT_FILE
	echo "created: $(date +%s)" >>$DOMOPI_IDENT_FILE
	# Incompatibile con aperturafile BASH: da rendere successivamente
	#chmod 444 $DOMOPI_IDENT_FILE

	# Generate global configuration file (empty with schema)
	echo "$DOMOPI_FILE_FINGERPRINT" '$global$' >$DOMOPI_GLOBAL_CONF
	echo "${DOMOPI_FILE_SCHEMA['global']}" >>$DOMOPI_GLOBAL_CONF

	# Install exportable version
	cp "$DOMOPI_CONF_TEMPLATE_PATH/$DOMOPI_MODULES_CONF" "$DOMOPI_EXTENDED_CONF_PATH/${DOMOPI_MODULES_CONF%%.$DOMOPI_CONF_EXTENTION}-$UUID.$DOMOPI_CONF_EXTENTION"
	chmod u+w "$DOMOPI_EXTENDED_CONF_PATH/${DOMOPI_MODULES_CONF%%.$DOMOPI_CONF_EXTENTION}-$UUID.$DOMOPI_CONF_EXTENTION"


	# Reboot API
	[ -f $DOMOPI_IDENT_FILE ] && domopi_ident 
	return 0
}


##
#
#	Genera file di struttura hardware
#
#	@author Andrea Tassotti
#
public domopi_install
function domopi_install
{
	if [ "$(id -un)" != "$DOMOPI_USER" ];
	then
		echo "ERROR: sorry! Only $DOMOPI_USER can install hardware configuration." >&2
		return 1
	fi

	if [ ! -f "$DOMOPI_CONF_TEMPLATE_PATH/$DOMOPI_MODULES_CONF" ]; then
		echo "Generate global configuration file (empty with schema) ..."
		echo "$DOMOPI_FILE_FINGERPRINT" '$modules$' >$DOMOPI_CONF_TEMPLATE_PATH/$DOMOPI_MODULES_CONF
		echo "${DOMOPI_FILE_SCHEMA['modules']}" >>$DOMOPI_CONF_TEMPLATE_PATH/$DOMOPI_MODULES_CONF

		echo Now available at $DOMOPI_CONF_TEMPLATE_PATH/$DOMOPI_MODULES_CONF
		echo
		echo "!!! Compile it before use API !!!"
		echo
	else
		echo "ERROR: hardware configuration exists in $DOMOPI_CONF_TEMPLATE_PATH." >&2
		return 2
	fi
}



##
#	Creazione configurazione oggetti di base
#
#	Ancora incompleto.
#	Scrive nel file determinato dalla variabile
#	ambientale DOMOPI_GLOBAL_CONF creato con domopi_init
#
#	$1 - 'sensor', 'group'
#	$2 - name
#
#	-d device UUID
#	-g groupid 
#	-p <patchNumber>
#	-t <type>
#	-w <wiredPI> x for null (force virtual)
#
#	@author Andrea Tassotti
#
public domopi_create
function domopi_create()
{
	local VERBOSE=false
	local PATCH
	local PATCHNUMBER
	local ret
	local device
	local DEFAULTSTATE
	local WIREDPI
	local TYPE
	local MODULES_CONF_FILE
	local IS_VIRTUAL=false
	local UUID=$DOMOPI_IDENT_UUID	# local device

	# Processa opzioni locali
	local OPTIND=1 OPTARG opt
	while getopts ":d:g:p:t:vw:" opt; do
		case $opt in
		d)	UUID=$OPTARG ;;	# remote device
		g)	GROUPID=$OPTARG ;;	# solo per sensori
		p)	PATCHNUMBER=$OPTARG ;;
		t)	TYPE=$OPTARG ;;
		v)	VERBOSE=true ;;
		w)	WIREDPI=$OPTARG ;;
		:)	echo argument required ; return ;;
		esac
	done
	shift $((OPTIND-1))

	MODULES_CONF_FILE="$DOMOPI_EXTENDED_CONF_PATH/${DOMOPI_MODULES_CONF%%.$DOMOPI_CONF_EXTENTION}-${UUID}.$DOMOPI_CONF_EXTENTION" 

	if [ ! -f "$MODULES_CONF_FILE" ]; then
		echo "ERROR: hardware running configuration missing." >&2
		return 2
	fi
	echo "NOTICE: selected $MODULES_CONF_FILE" >&2

	case "$1" in
	sensor)
		PATCH=""
		case "$TYPE" in
		"LIGHT")
			[ -n "$PATCHNUMBER" ] && PATCH="patchout:$PATCHNUMBER" 
			;;
		"NOLIGHT")
			[ -n "$PATCHNUMBER" ] && PATCH="patchout:$PATCHNUMBER" 
			;;
		"PUSH"|"SWITCH")
			[ -n "$PATCHNUMBER" ] && PATCH="patchin:$PATCHNUMBER" 
			;;
		"VSWITCH")
			[ -n "$PATCHNUMBER" ] && PATCH="patchin:$PATCHNUMBER" 
			IS_VIRTUAL=true
			DEFAULTSTATE=0
			;;
		"ALARM")
			[ -n "$PATCHNUMBER" ] && PATCH="patchout:$PATCHNUMBER patchin:$PATCHNUMBER" 
			;;
		"OTHER")
			;;
		"PULSE")
			[ -n "$PATCHNUMBER" ] && PATCH="patchin:$PATCHNUMBER" 
			;;
		"GPUSH"|"GSWITCH")
			[[ "$WIREDPI" == "x" ]] && IS_VIRTUAL=true
			DEFAULTSTATE=0
			if [ -n "$PATCHNUMBER" ] ; then
				echo 'ERROR: group push/switch *must* not have patch number' >&2 
				return 1
			fi
			if [ -z "$GROUPID" ]; then
				echo 'ERROR: group push/switch *must* have groupid. Use -g' >&2 
				return 1
			fi
			;;
		*)
			echo FATAL: type $TYPE not implemented >&2
			return 1
			;;
		esac

		# Ricerca wiredpi per tipo tra disponibili

		## un virtual switch non wiredpi
		if ! $IS_VIRTUAL ; then
			# Read schema
			_domopi_file_open "$MODULES_CONF_FILE"
			fd=$?	# Non usato direttamente
			[ $fd -eq 255 ] && return 1
			#$DOMOPI_SCHEMA_NAME

			if [ -z "$WIREDPI" ]; then
				_domopi_select_row -q "$MODULES_CONF_FILE" defaultstate wiredpi type=$TYPE used=false >/dev/null
				# Legge solo la prima risposta
				read DEFAULTSTATE REST <<< "${DOMOPI_defaultstate[@]}"
				read WIREDPI REST <<< "${DOMOPI_wiredpi[@]}"
				if [ -z "$WIREDPI" ] && [ "$TYPE" != "VSWITCH" ]
				then
					echo "ERROR: no more wiredpi available on device $UUID" >&2
					_domopi_file_close $fd
					return 1
				fi

				_domopi_update_row "$MODULES_CONF_FILE" used:true wiredpi=$WIREDPI
			else
				_domopi_select_row -q "$MODULES_CONF_FILE" used wiredpi="$WIREDPI" >/dev/null
				if [[ "${DOMOPI_used[@]}" = "true" ]] 
				then
					echo "ERROR: wiredpi $WIREDPI is used by a sensor on device $UUID" >&2
					_domopi_file_close $fd
					return 1
				fi
				[ -z "${DOMOPI_used[@]}" ] &&
					echo "ERROR: wiredpi $WIREDPI have no connection on device $UUID. May be not work properly" >&2

			fi

			_domopi_file_close $fd
		fi

		# Read configuration schema
		_domopi_file_open "$DOMOPI_GLOBAL_CONF"
		fd=$?	# Non usato direttamente
		[ $fd -eq 255 ] && return 1

		# Verifica gruppo (se espresso)
		if [ -n "$GROUPID" ]; then
			_domopi_select_row -q "$DOMOPI_GLOBAL_CONF" groupID "groupID=$GROUPID" >/dev/null
			[ ${#DOMOPI_groupID[@]} -eq 0 ] && echo ERROR: domopi_create: group $GROUPID does not exists. >&2 && return 3
		fi


		# TODO: device potrÃ  essere un ID sequenziale in presenza
		#		di master.cfg che definisca il legame con UUID
		echo "NOTICE: master.cfg ignored: device use UUID" >&2
		_domopi_insert_row "$DOMOPI_GLOBAL_CONF" device:"$UUID" sensorID:'*' "descriptionU:$2" currentstate:"$DEFAULTSTATE" wiredpi:"$WIREDPI" type:"$TYPE" groups:"$GROUPID" "$PATCH" 

		# NOTA: Il vincolo di univocitÃ  sulle descrizioni impone
		#		di alterare il nome originale.
		#
		#$AUTO_CREATE_VIRTUAL && [ "$TYPE" = "SWITCH" ] &&
		#_domopi_insert_row "$DOMOPI_GLOBAL_CONF" device:"$UUID" sensorID:'*' "descriptionU:${2}VIRT" currentstate:"$DEFAULTSTATE" type:"VSWITCH" "$PATCH" 
		#ret=$?

		_domopi_file_close $fd
		;;
	group)
		# Read schema
		_domopi_file_open "$DOMOPI_GLOBAL_CONF"
		fd=$?	# Non usato direttamente
		[ $fd -eq 255 ] && return 1

		_domopi_insert_row "$DOMOPI_GLOBAL_CONF" groupID:'*' "descriptionU:$2"
		ret=$?

		_domopi_file_close $fd
		;;
	*)
		echo FATAL: object $1 not implemented >&2
		return 1
		;;
	esac


	return $ret
}


##
#	Modifica attributi secondari per un sensore/gruppo
#
#	-d<UUID> Device
#	-g<ID>	Seleziona gruppo da modificare
#	-s<ID>	Selettore da modificare
#	-w<ID>	WiredPI da modificare
#	I selettori sono mutialmente esclusivi
#
#	$1 - Nome attributo
#	$2 - Nuovo valore
#
#	Attributi modificabili:
#	- patch
#	- maxExecutionTime
#	- description
#
#	@author Andrea Tassotti
#
public domopi_modify
function domopi_modify()
{
	local COLUMN_TO_MATCH=descriptionU
	local GROUP=false
	local UUID=$DOMOPI_IDENT_UUID	# local device
	local ret=1

	# Il file di configurazione deve esistere inizializzato
	# Read schema
	_domopi_file_open "$DOMOPI_GLOBAL_CONF"
	fd=$?	# Non usato direttamente
	[ $fd -eq 255 ] && return 1

	# Processa opzioni locali
	local OPTIND=1 OPTARG opt
	while getopts ":d:g:s:w:" opt; do
		case $opt in
		d)	UUID=$OPTARG ;;	# remote device
		g)	COLUMN_TO_MATCH="groups=[0-9\ ]*$OPTARG[0-9\ ]*";;
		s)	COLUMN_TO_MATCH="sensorID=$OPTARG";;
		w)	COLUMN_TO_MATCH="wiredpi=$OPTARG";;
		:)	echo argument required ; return ;;
		esac
	done
	shift $((OPTIND-1))


	_domopi_select_row -q "$DOMOPI_GLOBAL_CONF" descriptionU sensorID wiredpi type "$COLUMN_TO_MATCH" device="$UUID" >/dev/null

	for row in ${!DOMOPI_type[@]}
	do
		#echo ${DOMOPI_sensorID[$row]} ${DOMOPI_wiredpi[$row]} ${DOMOPI_descriptionU[$row]} ${DOMOPI_type[$row]}

		PATCH=""
		case "${DOMOPI_type[$row]}" in
		"LIGHT")
			[ -n "$2" ] && PATCH="patchout:$2" 
			;;
		"NOLIGHT")
			[ -n "$2" ] && PATCH="patchout:$2" 
			;;
		"PUSH"|"SWITCH")
			[ -n "$2" ] && PATCH="patchin:$2" 
			;;
		"VSWITCH")
			[ -n "$2" ] && PATCH="patchin:$2" 
			;;
		"ALARM")
			[ -n "$2" ] && PATCH="patchout:$2 patchin:$2" 
			;;
		"OTHER")
			;;
		"PULSE")
			[ -n "$2" ] && PATCH="patchin:$2" 
			;;
		*)
			;;
		esac
	
		# TODO: device potrÃ  essere un ID sequenziale in presenza
		#		di master.cfg che definisca il legame con UUID
		echo "NOTICE: master.cfg ignored: device use UUID" >&2

		case "$1" in
		patch)
			if [ "${DOMOPI_type[$row]}" = "GPUSH" ] ||
			   [ "${DOMOPI_type[$row]}" = "GSWITCH" ]; then
				echo ERROR: cannot use patch in Group Push/Switch >&2
				return 2
			fi

			_domopi_update_row "$DOMOPI_GLOBAL_CONF" "$PATCH" "$COLUMN_TO_MATCH" device="$UUID"
			;;
		max[eE]xecution[tT]ime)
			_domopi_update_row "$DOMOPI_GLOBAL_CONF" "maxExecutionTime:$2" "$COLUMN_TO_MATCH" device="$UUID"
			;;
		description)
			_domopi_update_row "$DOMOPI_GLOBAL_CONF" "descriptionU:$2" "$COLUMN_TO_MATCH" device="$UUID"
			;;
		esac
	done

	_domopi_file_close $fd
	return 0
}


##
#	Identifica il patch number per un sensore o gruppo
#
#	-d device UUID
#	-g<ID>	Seleziona gruppo da modificare
#	-s<ID>	Selettore da modificare
#	-w<ID>	WiredPI da modificare
#	I selettori sono mutialmente esclusivi
#
#	@author Andrea Tassotti
#
public domopi_get_patch
function domopi_get_patch()
{
	local COLUMN_TO_MATCH=descriptionU
	local UUID=$DOMOPI_IDENT_UUID	# local device
	local ret=1
	# Il file di configurazione deve esistere inizializzato
	# Read schema
	_domopi_file_open "$DOMOPI_GLOBAL_CONF"
	fd=$?	# Non usato direttamente
	[ $fd -eq 255 ] && return 1

	# Processa opzioni locali
	local OPTIND=1 OPTARG opt
	while getopts ":d:g:s:w:" opt; do
		case $opt in
		d)	UUID=$OPTARG ;;	# remote device
		g)	COLUMN_TO_MATCH="groups=[0-9\ ]*$OPTARG[0-9\ ]*";;
		s)	COLUMN_TO_MATCH="sensorID=$OPTARG";;
		w)	COLUMN_TO_MATCH="wiredpi=$OPTARG";;
		:)	echo argument required ; return ;;
		esac
	done
	shift $((OPTIND-1))

	_domopi_select_row -q "$DOMOPI_GLOBAL_CONF" type patchin patchout "$COLUMN_TO_MATCH" device="$UUID" >/dev/null

	for row in ${!DOMOPI_type[@]}
	do
		#echo ${DOMOPI_sensorID[$row]} ${DOMOPI_wiredpi[$row]} ${DOMOPI_descriptionU[$row]} ${DOMOPI_type[$row]}

		PATCH=""
		case "${DOMOPI_type[$row]}" in
		"LIGHT")
			echo ${DOMOPI_patchout[$row]}
			;;
		"NOLIGHT")
			echo ${DOMOPI_patchout[$row]}
			;;
		"PUSH"|"SWITCH")
			echo ${DOMOPI_patchin[$row]}
			;;
		"ALARM")
			echo ${DOMOPI_patchout[$row]} ${DOMOPI_patchin[$row]}
			;;
		"OTHER")
			;;
		"PULSE")
			echo ${DOMOPI_patchin[$row]}
			;;
		*)
			;;
		esac
	done

	_domopi_file_close $fd
	return 0
}


##
#	Distruzione di un oggetto di configurazione
#
#	Il criterio di ricerca Ã¨ una espressione regolare
#	sulla descrizione dell'oggetto. Utilizzare -n
#	per utilizzare un criterio basato su ID numerico.
#
#	$1 - Tipo oggetto
#	$2 - Criterio di ricerca
#	-n - Criterio di ricerca numerico
#	-d<UUID> Device
#
#	@author Andrea Tassotti
#
public domopi_destroy
function domopi_destroy()
{
	local VERBOSE=false
	local NUMERIC=false
	local UUID=$DOMOPI_IDENT_UUID	# local device
	local wirepi
	# Il file di configurazione deve esistere inizializzato

	# rocessa opzioni locali
	local OPTIND=1 OPTARG opt
	while getopts ":d:vn" opt; do
		case $opt in
		d)	UUID=$OPTARG ;;	# remote device
		v)	VERBOSE=true ;;
		n)	NUMERIC=true ;;
		:)	echo argument required ; return ;;
		esac
	done
	shift $((OPTIND-1))

	MODULES_CONF_FILE="$DOMOPI_EXTENDED_CONF_PATH/${DOMOPI_MODULES_CONF%%.$DOMOPI_CONF_EXTENTION}-${UUID}.$DOMOPI_CONF_EXTENTION" 
	if [ ! -f "$MODULES_CONF_FILE" ]; then
		echo $MODULES_CONF_FILE
		echo "ERROR: hardware running configuration missing." >&2
		return 2
	fi
	echo "NOTICE: selected $MODULES_CONF_FILE" >&2

	unset DOMOPI_wiredpi

	case "$1" in
	sensor)
		# Read schema conf
		_domopi_file_open "$DOMOPI_GLOBAL_CONF"
		fd=$?	# Non usato direttamente
		[ $fd -eq 255 ] && return 1

		# TODO: device potrÃ  essere un ID sequenziale in presenza
		#		di master.cfg che definisca il legame con UUID
		echo "NOTICE: master.cfg ignored: device use UUID" >&2

		if $NUMERIC ; then
			_domopi_select_row -q $DOMOPI_GLOBAL_CONF wiredpi device="$UUID" sensorID="$2" >/dev/null
			_domopi_delete_row $DOMOPI_GLOBAL_CONF device="$UUID" sensorID="$2"
			ret=$?
		else
			_domopi_select_row -q $DOMOPI_GLOBAL_CONF wiredpi device="$UUID" descriptionU="$2" >/dev/null
			_domopi_delete_row $DOMOPI_GLOBAL_CONF device="$UUID" descriptionU="$2"
			ret=$?
		fi
		_domopi_file_close $fd


		if [ $ret -eq 0 ]; then
			echo "Oggetto cancellato correttamente"
		else
			echo "Nessun oggetto cancellabile"
		fi
		;;
	group)
		# Read schema
		_domopi_file_open "$DOMOPI_GLOBAL_CONF"
		fd=$?	# Non usato direttamente
		[ $fd -eq 255 ] && return 1
		# Determinare ID del gruppo se fornito descrittore
		# Cercare sensori appartenenti al gruppo
		_domopi_select_row -q $DOMOPI_GLOBAL_CONF sensorID wiredpi "groups=[0-9\ ]*$2[0-9\ ]*" >/dev/null
		echo NOTICE: remove also ${#DOMOPI_sensorID[@]} sensors belong to group "$2"
		in=${DOMOPI_sensorID[@]}
		in=${in//\ /\|}
	
		_domopi_delete_row "$DOMOPI_GLOBAL_CONF" sensorID=$in

		if $NUMERIC ; then
			_domopi_delete_row $DOMOPI_GLOBAL_CONF groupID="$2"
			ret=$?
		else
			_domopi_delete_row $DOMOPI_GLOBAL_CONF sensorID="x" descriptionU="$2"
			ret=$?
		fi
		if [ $ret -eq 0 ]; then
			echo "Oggetto cancellato correttamente"
		else
			echo "Nessun oggetto cancellabile"
		fi

		_domopi_file_close $fd
		;;
	*)
		echo FATAL: not implemented >&2
		return 1
		;;
	esac

	# Allineamento allocazione wiredpi

	# Read schema modules
	_domopi_file_open $MODULES_CONF_FILE
	fd=$?	# Non usato direttamente
	[ $fd -eq 255 ] && return 1

	in=${DOMOPI_wiredpi[@]}
	in=${in//\ /\|}

	_domopi_update_row $MODULES_CONF_FILE used:false wiredpi=$in

	_domopi_file_close $fd

	return 0
}



#
#	Esegue una transizione di stato utilizzando un nome di colonna
#	variabile percercare gli oggetti da modificare
#
#	$1 - patch number
#	$2 - New state [0 = low, 1 = high]
#
#	La transizionepuÃ² avvenire senza restrizioni di device
#
#
#	Utilizza DOMOPI_PRE_TRANSITION_CALLBACK per eseguire un codice
#	prima di salvare la configurazione di stato: fornire nome di una
#	funzione definita
#	Utilizza DOMOPI_POST_TRANSITION_CALLBACK per eseguire un codice
#	prima di salvare la configurazione di stato: fornire nome di una
#	funzione definita
#	In entrambi i casi viene passato il valore del nuovo stato; sono
#	disponibili le colonne della configurazione sensorID e wiredpi con:
#	${DOMOPI_device[@]}		# Consente la trasmissione puntuale
#	${DOMOPI_sensorID[@]}
#	${DOMOPI_wiredpi[@]}
#	
#
#	@author Andrea Tassotti
#
function _domopi_do_sensor_transition()
{
	# Propagation
	_domopi_select_row -q "$DOMOPI_GLOBAL_CONF" device sensorID wiredpi patchout=$1 > /dev/null


	${DOMOPI_PRE_TRANSITION_CALLBACK:-true} $2

	# Simula clausola OR con due operazioni
	_domopi_update_row -v "$DOMOPI_GLOBAL_CONF" currentstate:$2 patchin=$1 
	_domopi_update_row -v "$DOMOPI_GLOBAL_CONF" currentstate:$2 patchout=$1 

	${DOMOPI_POST_TRANSITION_CALLBACK:-true} $2

	return 0
}


##
#	Imposta stato di un sensore o un gruppo di sensori
#
#	$1 - Criterio di ricerca
#	$2 - New state [0 = low, 1 = high]
#	-d device UUID
#	-n - Usa criterio di ricerca numerico (ID) invece che espressione regolare su descrizione
#	-w - Usa un criterio di ricerca numerico su wiredPI
#
#	Adotta la convenzione degli stati del comando gpio,
#	ma gli stati indicati in argomento non sono necessariamente
#	quelli per il sensore oggetto di modifica, in quanto
#	questi potranno essere modulati in ragione dell'essere il sensore
#	a logica inversa.
#
#	Aggiorna gli stati di tutti i sensori con patchin o patchout pari al
#	patchin del sensore su cui Ã¨ applicato. Non Ã¨ possibile settare
#	uno stato ad un sensore con solo patchout.
#
#	Utilizza DOMOPI_PRE_TRANSITION_CALLBACK per eseguire un codice
#	prima di salvare la configurazione di stato: fornire nome di una
#	funzione definita
#	Utilizza DOMOPI_POST_TRANSITION_CALLBACK per eseguire un codice
#	prima di salvare la configurazione di stato: fornire nome di una
#	funzione definita
#	In entrambi i casi viene passato il valore del nuovo stato; sono
#	disponibili le colonne della configurazione sensorID e wiredpi con:
#	${DOMOPI_sensorID[@]}
#	${DOMOPI_wiredpi[@]}
#
#	Per transizioni gruppi utilizza DOMOPI_GROUP_PRE_TRANSITION_CALLBACK
#	e DOMOPI_GROUP_POST_CALLBACK. A differenzadella callback per i sensori
#	normali, le funzioni per gruppo hanno seguente prototipo:
#	device sensorID wiredpi type state
#
#	e sono invocate solo su sensori con wiredpi non vuoto.
#
#
#	Esempio: domopi_set_state 1 1
#	Esempio: domopi_set_state 1 0
#
#
#	@author Andrea Tassotti
#
public domopi_set_state
function domopi_set_state()
{
	local COLUMN_TO_MATCH=descriptionU
	local UUID=$DOMOPI_IDENT_UUID	# local device
	local ret=1
	# Il file di configurazione deve esistere inizializzato
	# Read schema
	_domopi_file_open "$DOMOPI_GLOBAL_CONF"
	fd=$?	# Non usato direttamente
	[ $fd -eq 255 ] && return 1

	# Processa opzioni locali
	local OPTIND=1 OPTARG opt
	while getopts ":gnw" opt; do
		case $opt in
		d)	UUID=$OPTARG ;;	# remote device
		n)	COLUMN_TO_MATCH=sensorID ;;
		w)	COLUMN_TO_MATCH=wiredpi ;;	## IMPLICA DEVICE
		:)	echo argument required ; return ;;
		esac
	done
	shift $((OPTIND-1))

	if [[ "$2" != '0' ]] && [[ "$2" != '1' ]] ; then
		echo FATAL: GPIO interface only accept 0/1 values >&2
		return 1
	fi

	
	local patchnumber
	if [[ "$COLUMN_TO_MATCH" = "wiredpi" ]]; then
		echo _domopi_select_row -q "$DOMOPI_GLOBAL_CONF" type currentstate patchin device=$UUID groups $COLUMN_TO_MATCH=$1 
		_domopi_select_row -q "$DOMOPI_GLOBAL_CONF" type currentstate patchin device=$UUID groups $COLUMN_TO_MATCH=$1 >/dev/null
	else
		_domopi_select_row -q "$DOMOPI_GLOBAL_CONF" type currentstate patchin groups $COLUMN_TO_MATCH=$1 >/dev/null
	fi

	read type REST <<< ${DOMOPI_type[@]}
	read patchnumber REST <<< ${DOMOPI_patchin[@]}
	groups=${DOMOPI_groups[@]}

echo $type $patchnumber

	# No transition
	[[ $2 = ${DOMOPI_currentstate[0]} ]] && echo No transition && _domopi_file_close $fd && return 2

	if [[ "$type" = "GPUSH" ]] ||
	   [[ "$type" = "GSWITCH" ]]; then
		echo "Transizione stato per i gruppi: $groups"
		IN=""
		for group in $groups
		do
			IN="$IN([[:blank:][:digit:]]+)*${group}([[:blank:][:digit:]]+)*|"
		done
		IN=${IN%"${IN##*[!|]}"}
		# Imposta lo stato a tutti gli elementi nel gruppo; 
		# se nel gruppo sono presenti altri sensori in con patch number,
		# questi propagano tramite transizione per patch (comando a cascata).
		# gli GPUSH e GSWITCH non hanno per costruzione un patch number

		# Propagation
		_domopi_select_row -q "$DOMOPI_GLOBAL_CONF" device sensorID type wiredpi patchin groups="$IN" >/dev/null

		local _idx
		for((_idx=0;_idx<${#DOMOPI_sensorID[@]};_idx++))
		do
			if [ -z "${DOMOPI_patchin[$_idx]}" ] ; then
				echo Transizione sensore ${DOMOPI_sensorID[$_idx]} per gruppo
	
				[ -n "${DOMOPI_wiredpi[$_idx]}" ] && ${DOMOPI_GROUP_PRE_TRANSITION_CALLBACK:-true} ${DOMOPI_device[$_idx]} ${DOMOPI_sensorID[$_idx]} ${DOMOPI_wiredpi[$_idx]} ${DOMOPI_type[$_idx]} $2

				_domopi_update_row -v "$DOMOPI_GLOBAL_CONF" currentstate:$2 sensorID=${DOMOPI_sensorID[$_idx]}
				ret=$?

				[ -n "${DOMOPI_wiredpi[$_idx]}" ] && ${DOMOPI_GROUP_POST_TRANSITION_CALLBACK:-true} ${DOMOPI_device[$_idx]} ${DOMOPI_sensorID[$_idx]} ${DOMOPI_wiredpi[$_idx]} ${DOMOPI_type[$_idx]} $2
			else
				echo Propagazione transizione sensore ${DOMOPI_sensorID[$_idx]} per patch number ${DOMOPI_patchin[$_idx]}
				# ATTENZIONE: Usare sottoshell per evitare conflitto variabili DOMOPI_
				( _domopi_do_sensor_transition "${DOMOPI_patchin[$_idx]}" "$2" )
				ret=$?
			fi
		done

	else	
		# No propagation
		[ -z "$patchnumber" ] && echo WARNING: Given sensor is not an input >&2 && _domopi_file_close $fd && return 0

		_domopi_do_sensor_transition "$patchnumber" "$2"
		ret=$?
	fi

	echo 
	echo Sincronizzazioni

	# Sincronizzazione stati interruttori (per patch nummber)
	declare -A stateon
	declare -A stateoff
	
	_domopi_select_row -q "$DOMOPI_GLOBAL_CONF" patchout currentstate patchout=!null >/dev/null

	# Una specie di Group by (considerando solo i due stati possibili) + count
	local patch
	for((_idx=0;_idx<${#DOMOPI_currentstate[@]};_idx++))
	do
		if [ ${DOMOPI_currentstate[$_idx]} -eq 0 ]; then
			patch=${DOMOPI_patchout[$_idx]}
			[ -z "${stateoff[$patch]}" ] && stateoff[$patch]=0
			stateoff[$patch]=$(( ${stateoff[$patch]} + 1 ))
		else
			patch=${DOMOPI_patchout[$_idx]}
			[ -z "${stateon[$patch]}" ] && stateon[$patch]=0
			stateon[$patch]=$(( ${stateon[$patch]} + 1 ))
		fi
	done

	for patch in ${!stateon[@]} ${!stateoff[@]}
	do
		if [ -z "${stateon[$patch]}" ]; then
			echo Patch $patch non ha stati ON, quindi lo stato totale Ã¨ OFF
			_domopi_update_row -v "$DOMOPI_GLOBAL_CONF" currentstate:0 patchin="$patch" currentstate=1
		fi
		if [ -z "${stateoff[$patch]}" ]; then
			echo Patch $patch non ha stati OFF, quindi lo stato totale Ã¨ ON
			_domopi_update_row -v "$DOMOPI_GLOBAL_CONF" currentstate:1 patchin="$patch" currentstate=0
		fi
	done

	# Sincronizzazione stati interruttori (per gruppo)
	unset stateon
	unset stateoff
	declare -A stateon
	declare -A stateoff

	_domopi_select_row -q "$DOMOPI_GLOBAL_CONF" groups currentstate groups=!null type="LIGHT|NOLIGHT|PULSE|OTHER" >/dev/null
	# Una specie di Group by (considerando solo i due stati possibili) + count
	local groups
	for((_idx=0;_idx<${#DOMOPI_currentstate[@]};_idx++))
	do
		if [ ${DOMOPI_currentstate[$_idx]} -eq 0 ]; then
			for group in ${DOMOPI_groups[$_idx]}
			do
				[ -z "${stateoff[$group]}" ] && stateoff[$group]=0
				stateoff[$group]=$(( ${stateoff[$group]} + 1 ))
			done
		else
			for group in ${DOMOPI_groups[$_idx]}
			do
				[ -z "${stateon[$group]}" ] && stateon[$group]=0
				stateon[$group]=$(( ${stateon[$group]} + 1 ))
			done
		fi
	done

	for group in ${!stateon[@]} ${!stateoff[@]}
	do
		if [ -z "${stateon[$group]}" ]; then
			echo Gruppo $group non ha stati ON, quindi lo stato totale Ã¨ OFF
			_domopi_update_row -v "$DOMOPI_GLOBAL_CONF" currentstate:0 "groups=[0-9\ ]*$group[0-9\ ]*" currentstate=1
		fi
		if [ -z "${stateoff[$group]}" ]; then
			echo Gruppo $group non ha stati OFF, quindi lo stato totale Ã¨ ON
			_domopi_update_row -v "$DOMOPI_GLOBAL_CONF" currentstate:1 "groups=[0-9\ ]*$group[0-9\ ]*" currentstate=0
		fi
	done

	_domopi_file_close $fd
	return $ret
}



##
#	Legge stato di un sensore o gruppo
#
#	$1 - Criterio di ricerca
#	-d device UUID
#	-g - Il criterio di ricerca si riferisce ad un gruppo
#	-n - Usa criterio di ricerca numerico (ID) invece che espressione regolare su descrizione
#	-w - Usa un criterio di ricerca numerico su wiredPI
#
#	Restituisce lo stato in STDOUT (potendo essere anche alfanumerico)
#	Distribuito anche come ${DOMOPI_currentstate[0]}
#	Possibile avere elenco stati piÃ¹ oggetti secriterio non selettivo
#	Non forza uso di alcun tipo (ouo' essere numerico o alfanumerico)
#
#
#	Esempio: domopi_get_state -n 1
#
#
#	TODO: Implementare selettore per modulo e gruppo
#
#	@author Andrea Tassotti
#
public domopi_get_state
function domopi_get_state()
{
	local COLUMN_TO_MATCH=descriptionU
	local UUID=$DOMOPI_IDENT_UUID	# local device
	local GROUP=false
	# Il file di configurazione deve esistere inizializzato
	# Read schema
	_domopi_file_open "$DOMOPI_GLOBAL_CONF"
	fd=$?	# Non usato direttamente
	[ $fd -eq 255 ] && return 1

	# Processa opzioni locali
	local OPTIND=1 OPTARG opt
	while getopts ":gnw" opt; do
		case $opt in
		d)	UUID=$OPTARG ;;	# remote device
		g)	GROUP=true ;;
		n)	COLUMN_TO_MATCH=sensorID ;;
		w)	COLUMN_TO_MATCH=wiredpi ;;
		:)	echo argument required ; return ;;
		esac
	done
	shift $((OPTIND-1))

	if $GROUP ; then
		echo gruppi non implementati
	#		_domopi_select_row -q "$DOMOPI_GLOBAL_CONF" currentstate groupID=$1
	#		_domopi_select_row -q "$DOMOPI_GLOBAL_CONF" currentstate sensorID=x descriptionU="$1"
	else
			_domopi_select_row -q "$DOMOPI_GLOBAL_CONF" currentstate $COLUMN_TO_MATCH="$1" device="$UUID"
	fi

	_domopi_file_close $fd
	return 0
}


##
#	Legge il tipo di un sensore
#
#	$1 - Criterio di ricerca
#	-d device UUID
#	-n - Usa criterio di ricerca numerico (ID) invece che espressione regolare su descrizione
#	-w - Usa un criterio di ricerca numerico su wiredPI
#
#	Restituisce il tipo in STDOUT 
#	Distribuito anche come ${DOMOPI_type[0]}
#
#	NOTA: Non esiste funzione set in quanto il tipo Ã¨ parte 
#	della definizione di un oggetto
#
#	Esempio: domopi_get_state -n 1 
#
#	@author Andrea Tassotti
#
public domopi_get_type
function domopi_get_type()
{
	local COLUMN_TO_MATCH=descriptionU
	local UUID=$DOMOPI_IDENT_UUID	# local device
	# Il file di configurazione deve esistere inizializzato
	# Read schema
	_domopi_file_open "$DOMOPI_GLOBAL_CONF"
	fd=$?	# Non usato direttamente
	[ $fd -eq 255 ] && return 1

	# Processa opzioni locali
	local OPTIND=1 OPTARG opt
	while getopts ":gnw" opt; do
		case $opt in
		d)	UUID=$OPTARG ;;	# remote device
		n)	COLUMN_TO_MATCH=sensorID ;;
		w)	COLUMN_TO_MATCH=wiredpi ;;
		:)	echo argument required ; return ;;
		esac
	done
	shift $((OPTIND-1))

	_domopi_select_row -q "$DOMOPI_GLOBAL_CONF" type $COLUMN_TO_MATCH="$1" device="$UUID"

	_domopi_file_close $fd
	return 0
}


##
#	Legge la descrizione un sensore
#
#	-d device UUID
#	-s<ID> - Ricerca per sendorID
#	-w<ID> - Ricerca per wiredPI
#
#	Restituisce la descrizione in STDOUT 
#	Distribuito anche come ${DOMOPI_descriptionU[0]}
#
#
#	Esempio: domopi_get_description -n 1 
#
#	@author Andrea Tassotti
#
public domopi_get_description
function domopi_get_description()
{
	local COLUMN_TO_MATCH=descriptionU
	local UUID=$DOMOPI_IDENT_UUID	# local device
	# Il file di configurazione deve esistere inizializzato
	# Read schema
	_domopi_file_open "$DOMOPI_GLOBAL_CONF"
	fd=$?	# Non usato direttamente
	[ $fd -eq 255 ] && return 1

	# Processa opzioni locali
	local OPTIND=1 OPTARG opt
	while getopts ":g:s:w:" opt; do
		case $opt in
		d)	UUID=$OPTARG ;;	# remote device
		s)	COLUMN_TO_MATCH=sensorID; VALUE_TO_MATCH=$OPTARG ;;
		w)	COLUMN_TO_MATCH=wiredpi ; VALUE_TO_MATCH=$OPTARG ;;
		:)	echo argument required ; return ;;
		esac
	done
	shift $((OPTIND-1))

	echo _domopi_select_row -q "$DOMOPI_GLOBAL_CONF" descriptionU $COLUMN_TO_MATCH="$VALUE_TO_MATCH" device="$UUID"
	_domopi_select_row -q "$DOMOPI_GLOBAL_CONF" descriptionU $COLUMN_TO_MATCH="$VALUE_TO_MATCH" device="$UUID"

	_domopi_file_close $fd
	return 0
}

##
# Lista degli oggetti di configurazioni selezionati per tipo
#
#	$1 - Tipo (sensor, group, ...)
#
#	Indica ID, descrizione e stato
#
#	@author Andrea Tassotti
#
public domopi_list
function domopi_list()
{
	## Read schema
	_domopi_file_open "$DOMOPI_GLOBAL_CONF"
	fd=$?	# Non usato direttamente

	case "$1" in
	sensor)
		_domopi_select_row "$DOMOPI_GLOBAL_CONF" device sensorID descriptionU currentstate wiredpi patchin patchout groups "groupID=x"
		;;
	group)
		(
		echo -e "groupID\tdescriptionU\tsensors"
		_domopi_select_row -q "$DOMOPI_GLOBAL_CONF" groupID descriptionU sensorID=x >/dev/null
		for index in ${!DOMOPI_groupID[@]}
		do
			echo -ne "${DOMOPI_groupID[$index]}\t${DOMOPI_descriptionU[$index]}\t"
			(
			# NOTA: Le vatiabili DOMOPI_ hanno qui altro scope
			domopi_get_sensors_of_group ${DOMOPI_groupID[$index]} >/dev/null
			echo ${DOMOPI_descriptionU[@]}	|tr ' ' ','
			)
		done 
		)| column -t -s $'\t'

		;;
	*)
		echo NON IMPLEMENTATO
		;;
	esac

	_domopi_file_close $fd
}


##
#	Ricerca i wiredpi utilizzati in configurazione
#
#	Le opzioni di ricerca sono cumulabili in AND
#	
#	-d<id>	ricerca per device
#	-s<id>	ricerca per sensorID
#	-t<in/out>	ricerca per tipo
#	-v	Verbose mode
#
#
#	@author Andrea Tassotti
#
public domopi_get_wiredpi
function domopi_get_wiredpi()
{
	local VERBOSE=false
	local COLUMNS_TO_MATCH=""
	local UUID=$DOMOPI_IDENT_UUID	# local device
	local ret
	# Il file di configurazione deve esistere inizializzato
	# Read schema
	_domopi_file_open "$DOMOPI_GLOBAL_CONF"
	fd=$?	# Non usato direttamente
	[ $fd -eq 255 ] && return 1

	# Processa opzioni locali
	local OPTIND=1 OPTARG opt
	while getopts ":d:s:t:vw:" opt; do
		case $opt in
		d)	COLUMNS_TO_MATCH="${COLUMNS_TO_MATCH}device=$OPTARG " ;;
		s)	COLUMNS_TO_MATCH="${COLUMNS_TO_MATCH}sensorID=$OPTARG " ;;
		t)	case "$OPTARG" in	
			in)	 COLUMNS_TO_MATCH="${COLUMNS_TO_MATCH}patchin='!null' " ;;
			out) COLUMNS_TO_MATCH="${COLUMNS_TO_MATCH}patchout='!null' " ;;
			esac
			;;
		v)	VERBOSE=true ;;
		:)	echo argument required ; return ;;
		esac
	done
	shift $((OPTIND-1))

	
	if $VERBOSE ; then
		eval _domopi_select_row \"$DOMOPI_GLOBAL_CONF\" device wiredpi descriptionU $COLUMNS_TO_MATCH
	else
		eval _domopi_select_row -q \"$DOMOPI_GLOBAL_CONF\" device wiredpi $COLUMNS_TO_MATCH
	fi

	_domopi_file_close $fd
}


##
#	Aggiunge un sensore ad un gruppo
#
#	$1 - groupID
#	$2 - sensorID
#
#	@author Andrea Tassotti
#
public domopi_group_add_sensor
function domopi_group_add_sensor()
{
	local VERBOSE=false
	local ret
	# Il file di configurazione deve esistere inizializzato

	# Processa opzioni locali
	local OPTIND=1 OPTARG opt
	while getopts ":v" opt; do
		case $opt in
		v)	VERBOSE=true ;;
		:)	echo Option argument required ; return 1 ;;
		esac
	done
	shift $((OPTIND-1))

	[ $# -lt 2 ] && echo Argument required && return 2

	# Read schema
	_domopi_file_open "$DOMOPI_GLOBAL_CONF"
	fd=$?	# Non usato direttamente
	[ $fd -eq 255 ] && return 1
	
	_domopi_select_row -q "$DOMOPI_GLOBAL_CONF" groupID "groupID=$1" >/dev/null
	[ ${#DOMOPI_groupID[@]} -eq 0 ] && echo ERROR: domopi_group_add_sensor: group $1 does not exists. >&2 && return 3

	_domopi_select_row -q "$DOMOPI_GLOBAL_CONF" groups "sensorID=$2" >/dev/null

	# BUG: Non usare direttamente espressione ${DOMOPI_groups[@]}
	# nei doppi apici
	OLDGROUPS=${DOMOPI_groups[@]}
# TODO: sostituire grep con altro
	if ! echo $OLDGROUPS | grep -w $1 >/dev/null ; then
		groups="$OLDGROUPS $1"
		groups=${groups## }
		groups=${groups%% }
		_domopi_update_row -q "$DOMOPI_GLOBAL_CONF" groups:"$groups" "sensorID=$2"
	else
		echo WARNING: domopi_group_add_sensor: sensor $2 belong to group $1 yet
	fi

	_domopi_file_close $fd
}



##
#	$1 - groupID
#	$2 - sensorID
#
#	@author Andrea Tassotti
#
public domopi_group_remove_sensor
function domopi_group_remove_sensor()
{
	local VERBOSE=false
	local ret
	# Il file di configurazione deve esistere inizializzato

	# Processa opzioni locali
	local OPTIND=1 OPTARG opt
	while getopts ":v" opt; do
		case $opt in
		v)	VERBOSE=true ;;
		:)	echo Option argument required ; return 1 ;;
		esac
	done
	shift $((OPTIND-1))

	[ $# -lt 2 ] && echo Argument required && return 2

	# Read schema
	_domopi_file_open "$DOMOPI_GLOBAL_CONF"
	fd=$?	# Non usato direttamente
	[ $fd -eq 255 ] && return 1

	_domopi_select_row -q "$DOMOPI_GLOBAL_CONF" groups "sensorID=$2" >/dev/null
	read groups rest <<< "${DOMOPI_groups[@]}"


	group=${1//\ /}
	groups=" $groups "
	groups="${groups/@( )${group}@( )/ }"
	groups=${groups## }
	groups=${groups%% }
	[ -z "$groups" ] && groups=x
	_domopi_update_row -q "$DOMOPI_GLOBAL_CONF" groups:"$groups" "sensorID=$2"

	_domopi_file_close $fd
}


##
#	I gruppi a cui appartiene un sensore
#
#	$1 - Sensore
#
#	TODO: Aumentare informazioni
#
#	@author Andrea Tassotti
#
public domopi_get_groups
function domopi_get_groups()
{
	_domopi_select_row -q "$DOMOPI_GLOBAL_CONF" groups "sensorID=$1" >/dev/null
}


##
#	I sensori in un gruppo
#
#	$1 - sensorID
#
#	@author Andrea Tassotti
#
public domopi_get_sensors_of_group
function domopi_get_sensors_of_group()
{
	_domopi_select_row -q "$DOMOPI_GLOBAL_CONF" device sensorID descriptionU "groups=[0-9\ ]*$1[0-9\ ]*"
}


##
#
#
#	@author Andrea Tassotti
#
function _domopi_toggle_state()
{
	[[ $1 -eq 0 ]] && return 1
	return 0
}


##
#	Poll for states of a list of sensors
#
#	Da eseguire con cadenza definita da progetto hardware.	
#	CuriositÃ : Il nome deriva dalla primitiva di sistema Unix omonima
#
#	Supporto intettuttori (memoria di stato fisica)
#	Supporto pulsanti (memoria di stato software)
#
#	Gestito mediante tipo sensore:
#		*SWITCH -> interruttore
#		*PUSH	-> pulsante
#
#
#	Write in DOMOPI_PIPE
#
#	@author Andrea Tassotti
#
public domopi_select
function domopi_select()
{
	local UUID=$DOMOPI_IDENT_UUID   # local device

	_domopi_file_open "$DOMOPI_GLOBAL_CONF"
	fd=$?	# Non usato direttamente
	[ $fd -eq 255 ] && return 1


	_domopi_select_row -q "$DOMOPI_GLOBAL_CONF" wiredpi currentstate device="$UUID" type patchin=!null wiredpi=!null >/dev/null

	
	for idx in ${!DOMOPI_wiredpi[@]}
	do
		# Deve restituire il nuovo stato
		${DOMOPI_POLL_CALLBACK:-true} ${DOMOPI_wiredpi[$idx]}
		hwstate=$?

		if [[ ${DOMOPI_type[$idx]} =~ SWITCH$ ]]
		then
			if [ $newState -ne ${DOMOPI_currentstate[$idx]} ] ; then
				echo ${DOMOPI_wiredpi[$idx]} $newState none >$DOMOPI_PIPE
			fi
		elif [[ ${DOMOPI_type[$idx]} =~ PUSH$ ]]
		then
			if [ $hwstate -eq 0 ] ; then
				if [[ ${DOMOPI_pushed[$idx]} -ne 1 ]]; then
					# Push down
					_domopi_toggle_state $hwstate
					newState=$?
					# supporting modifier
					echo ${DOMOPI_wiredpi[$idx]} $newState none >$DOMOPI_PIPE 
					DOMOPI_pushed[$idx]=1
				fi
			else
				# Push up
				DOMOPI_pushed[$idx]=0
			fi	
		fi
	done 

	_domopi_file_close $fd
	return 0
}


##
#	Fetch from DOMOPI_PIPE and set sensor states
#
#
#	Read from DOMOPI_PIPE and act state
#	Use domopi_set_state
#
#	@author Andrea Tassotti
#
public domopi_fetch
function domopi_fetch()
{
	[ ! -p $DOMOPI_PIPE ] && return 1

	read wiredpi state modifier < $DOMOPI_PIPE
	domopi_set_state -w $wiredpi $state >/dev/null
	echo $?	# Numero transazioni derivanti

	return 0
}


##
#
#	Imposta il sistema ad uno stato noto
#
#	Senza parametri pone a default gli stati dei sensori
#	Il parametro Ã¨ il file di configurazione da utilizzare
#	per ripristinare lo stato dei sensori. Il filenon viene alterato
#
#	Utilizzabile anche per ripristinare uno stato noto definito da
#	una configurazione salvata
#	Il file di configurazione usato deve esistere e con gli stessi
#	sensori di quello running
#
#	Ogni device provvede al proprio riavvio?
#
#	$1 - File configurazione (opzionale)
#
#	@author Andrea Tassotti
#
public domopi_reset
function domopi_reset()
{
	local fd
	local ret=1
	local UUID=$DOMOPI_IDENT_UUID	# local device
	local MODULES_CONF_FILE="$DOMOPI_EXTENDED_CONF_PATH/${DOMOPI_MODULES_CONF%%.$DOMOPI_CONF_EXTENTION}-${UUID}.$DOMOPI_CONF_EXTENTION" 

	if [ $# -eq 0 ]; then
	# Reset configuration to default state
	#
	
	# Read schema
		_domopi_file_open "$MODULES_CONF_FILE"
		fd=$?	# Non usato direttamente
		[ $fd -eq 255 ] && return 1

		_domopi_select_row -q "$MODULES_CONF_FILE" defaultstate wiredpi used=true >/dev/null
		
		_domopi_file_close $fd

		# Il file di configurazione deve esistere inizializzato
		# Read schema
		_domopi_file_open "$DOMOPI_GLOBAL_CONF"
		fd=$?	# Non usato direttamente
		[ $fd -eq 255 ] && return 1

		for idx in ${!DOMOPI_wiredpi[@]}
		do
			_domopi_update_row -v "$DOMOPI_GLOBAL_CONF" currentstate:${DOMOPI_defaultstate[$idx]} wiredpi=${DOMOPI_wiredpi[$idx]}
		done
		_domopi_file_close $fd
	else
		# Reset sensor out to known state

		# Read schema
		_domopi_file_open "$1"
		fd=$?	# Non usato direttamente
		[ $fd -eq 255 ] && return 1

		# Per consentire di utilizzare la medesima interfaccia callback
		# resettiamo per stati diversi
		_domopi_select_row -q "$1" device sensorID wiredpi patchin=null currentstate=0 > /dev/null
		${DOMOPI_PRE_TRANSITION_CALLBACK:-true} 0
		${DOMOPI_POST_TRANSITION_CALLBACK:-true} 0

		_domopi_select_row -q "$1" device sensorID wiredpi patchin=null currentstate=1 > /dev/null
		${DOMOPI_PRE_TRANSITION_CALLBACK:-true} 1
		${DOMOPI_POST_TRANSITION_CALLBACK:-true} 1
		_domopi_file_close $fd
	fi
}


##
#	Realizza le fasi di bootstrap del sistema
#
#	In particolare esegue reset dei sensori e pone
#	file marcatore che deve essere rimosso allo shutdown.
#	La mancata rimozione di tale file indica un powerfail.
#
#	in caso di accensione normale pone a default lo stato dei sensori eseguendo domopi_reset senza parametri
#	in caso di powerfail ripristina lo stato dei sensori all'ultimo stato noto eseguendo domopi_reset con il file di configurazione running.
#
#	@author Andrea Tassotti
#
public domopi_poweron
function domopi_poweron()
{
	if [ -f "$DOMOPI_POWERON_FILE" ]
	then
		# Powerfail
		domopi_reset "$DOMOPI_GLOBAL_CONF"
	else
		domopi_reset
	fi
	touch "$DOMOPI_POWERON_FILE"
}



##
#	Esegue le procedure per lo spegnimento del sistema
#	Indica un corretto spegnimento al sistema durante il poweron
#
#	@author Andrea Tassotti
#
public domopi_shutdown
function domopi_shutdown()
{
	rm -f "$DOMOPI_POWERON_FILE"
}


##
#	Mostra il contenuto del file master
#
#	@author Andrea Tassotti
#
public domopi_show_hardware
function domopi_show_hardware()
{
	local MODULES_CONF_FILE
	local UUID=$DOMOPI_IDENT_UUID   # local device

	MODULES_CONF_FILE="$DOMOPI_EXTENDED_CONF_PATH/${DOMOPI_MODULES_CONF%%.$DOMOPI_CONF_EXTENTION}-${UUID}.$DOMOPI_CONF_EXTENTION" 

	if [ ! -f "$MODULES_CONF_FILE" ]; then
		echo "ERROR: hardware running configuration missing." >&2
		return 2
	fi
	echo "NOTICE: selected $MODULES_CONF_FILE" >&2

	echo 
	# Read schema
	_domopi_file_open "$MODULES_CONF_FILE"
	fd=$?	# Non usato direttamente
	[ $fd -eq 255 ] && return 1
	#$DOMOPI_SCHEMA_NAME

	if [ -z "$WIREDPI" ]; then
		_domopi_select_row "$MODULES_CONF_FILE" modulename type wiredpi used 
	fi

	_domopi_file_close $fd
}

#-----------------------------------------------
# End-of-API
#-----------------------------------------------


#
# Bootstrap
#
echo DomoPI API bootstrap ...
shopt -s expand_aliases 
shopt -s extglob 
[ -f $DOMOPI_IDENT_FILE ] && domopi_ident 

[ ! -d $DOMOPI_PIPE_PATH ] && echo "FATAL: no such directory: $DOMOPI_PIPE_PATH" >&2 && exit 1
[ ! -p $DOMOPI_PIPE ] && mkfifo $DOMOPI_PIPE

echo -n "  PUSH BUTTON initialization ... "

GPIO_CMD=$(which gpio)

# Read schema
if [ -x "$GPIO_CMD" ] ; then
	_domopi_file_open "$DOMOPI_MODULES_CONF"
	fd=$?	# Non usato direttamente
	[ $fd -eq 255 ] && return 1
	_domopi_select_row -q "$DOMOPI_MODULES_CONF" wiredpi "type=[G]{0,1}PUSH" >/dev/null
	for wiredpi in ${DOMOPI_wiredpi[@]}
	do
		echo -n "$wiredpi "
		$GPIO_CMD mode $wirepi tri >/dev/null 2>&1
	done
	echo done.
else
	echo Fail. Missing gpio command.
fi
_domopi_file_close $fd



#
# Esempi d'uso
#-----------------------------

# ./domopi.functions   # NON ESEGUE !
# . domopi.functions   # include la libreria
# 
# Sono diponibili come comandi (quindi anche come funzioni se incluso in un ulteriore script)
# le sole funzioni non dichiarate private.
# 
# Quindi possiamo scrivere:
# 
# domopi_ident
# 
# e ottenere a STDOUT l'identitÃ  (per un uso interattivoi e quindi feedback utente) 
# 
# oppure usare 
# 
# domopi_ident >/dev/null
# 
# per utilizzare solo la variabile DOMOPI_IDENT (uso interno ad uno script, senza over utilizzare costrutti per leggere stdout in variabile).
# 
# Il passaggio argomenti Ã¨ ovviamente consentito come per ogni funzione bash.
# 

